# 测试工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#testing-tools)

为了执行安全测试，可以使用不同的工具来操纵请求和响应、反编译应用程序、调查正在运行的应用程序和其他测试用例的行为并使它们自动化。

> MASTG 项目没有偏好以下任何工具，也没有推广或销售任何工具。以下所有工具均已验证是否“有效”，这意味着最近已推送更新。尽管如此，并不是所有的工具都被作者使用/测试过，但它们在分析移动应用程序时可能仍然有用。该列表按字母顺序排序。该列表还指出了商业工具。
>
> 免责声明：在撰写本文时，我们确保 MASTG 示例中使用的工具正常工作。但是，这些工具可能会损坏或无法正常工作，具体取决于您的主机和测试设备的操作系统版本。该工具的功能可能会因您是否使用已获得 root 权限/越狱的设备、root 权限/越狱方法的特定版本和/或该工具的版本而受到进一步阻碍。MASTG 不对工具的工作状态承担任何责任。如果您发现损坏的工具或示例，请在工具原始页面（例如 GitHub 问题页面）中搜索或提交问题。

## 适用于所有平台的工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tools-for-all-platforms)

### Angr[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#angr)

#### Angr (Android)[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#angr-android)

Angr 是一个用于分析二进制文件的 Python 框架。它对静态和动态符号（“concolic”）分析都很有用。换句话说：给定一个二进制文件和一个请求的状态，Angr 将尝试进入该状态，使用形式化方法（一种用于静态代码分析的技术）来寻找路径，以及暴力破解。使用 angr 到达请求的状态通常比手动调试和搜索通往所需状态的路径要快得多。Angr 在 VEX 中间语言上运行，并带有 ELF/ARM 二进制文件的加载程序，因此它非常适合处理原生代码，例如原生 Android 二进制文件。

Angr 允许反汇编、程序检测、符号执行、控制流分析、数据依赖性分析、反编译等，提供大量插件。

从版本 8 开始，Angr 基于 Python 3，可以在 *nix 操作系统、macOS 和 Windows 上使用 pip 安装：

```
pip install angr
```

> angr 的一些依赖项包含 Python 模块 Z3 和 PyVEX 的分叉版本，它们会覆盖原始版本。如果您将这些模块用于其他用途，您应该使用[Virtualenv](https://docs.python.org/3/tutorial/venv.html)创建一个专用的虚拟环境。或者，您始终可以使用提供的 docker 容器。有关详细信息，请参阅[安装指南。](https://docs.angr.io/introductory-errata/install)

[Angr 的 Gitbooks 页面](https://docs.angr.io/)上提供了全面的文档，包括安装指南、教程和使用示例。还提供了完整的[API 参考。](https://angr.io/api-doc/)

您可以使用来自 Python REPL（例如 iPython）的 angr 或编写您的方法。尽管 angr 的学习曲线有点陡峭，但我们还是建议您在想要暴力破解可执行文件的给定状态时使用它。请参阅“逆向工程和篡改”一章的“[符号执行](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/#symbolic-execution)”部分作为一个很好的例子来说明它是如何工作的。

### Frida[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida)

[Frida](https://www.frida.re/)是由 Ole André Vadla Ravnås 编写的免费开源动态代码检测工具包，它通过将[QuickJS](https://bellard.org/quickjs/) JavaScript 引擎（以前的[Duktape](https://duktape.org/)和[V8](https://v8.dev/docs)）注入检测过程来工作。Frida 允许您在 Android 和 iOS（以及[其他平台](https://www.frida.re/docs/home/)）上的原生应用程序中执行 JavaScript 片段。

要在本地安装 Frida，只需运行：

```
pip install frida-tools
```

或参阅[安装页面](https://www.frida.re/docs/installation/)了解更多详情。

可以通过多种方式注入代码。例如，Xposed 会永久修改 Android 应用程序加载器，为每次启动新进程时运行您自己的代码提供Hook。相比之下，Frida 通过直接将代码写入进程内存来实现代码注入。附加到正在运行的应用程序时：

- Frida 使用 ptrace 劫持正在运行的进程的线程。该线程用于分配一块内存并用迷你引导程序填充它。
- 引导程序启动一个新线程，连接到设备上运行的 Frida 调试服务器，并加载包含 Frida 代理 ( `frida-agent.so`) 的共享库。
- 代理建立返回工具的双向通信通道（例如 Frida REPL 或您的自定义 Python 脚本）。
- 被劫持的线程在恢复到原来的状态后恢复，进程继续照常执行。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04/frida.png)

- *Frida 架构，来源：[https ://www.frida.re/docs/hacking/](https://www.frida.re/docs/hacking)*

Frida 提供三种操作模式：

1. 注入：这是 frida-server 在 iOS 或 Android 设备中作为守护进程Runtime(运行时)最常见的场景。frida-core 通过 TCP 暴露，默认监听 localhost:27042。在未获得 root 权限或未越狱的设备上无法在此模式下运行。
2. 嵌入式：当你的设备没有 root 也没有越狱时（你不能以非特权用户身份使用 ptrace），你负责通过手动或通过第三方将[frida-gadget](https://www.frida.re/docs/gadget/)库嵌入到你的应用程序中来注入 frida-gadget 库党的工具，如[objection](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#objection)。
3. 预加载：类似于`LD_PRELOAD`或`DYLD_INSERT_LIBRARIES`。您可以将 frida-gadget 配置为自主运行并从文件系统加载脚本（例如，相对于 Gadget 二进制文件所在的路径）。

独立于所选模式，您可以使用[Frida JavaScript API](https://www.frida.re/docs/javascript-api/)与正在运行的进程及其内存进行交互。一些基本的 API 是：

- [拦截器](https://www.frida.re/docs/javascript-api/#interceptor)：当使用拦截器 API 时，Frida 会在函数序言处注入一个蹦床（又名内联Hook），这会引发对我们自定义代码的重定向，执行我们的代码，然后返回到原始函数。请注意，虽然对我们的目的非常有效，但这会带来相当大的开销（由于与蹦床相关的跳跃和上下文切换）并且不能被视为透明的，因为它会覆盖原始代码并类似于调试器（放置断点），因此可以以类似的方式检测到，例如，通过定期对自己的代码进行校验和的应用程序检测到。
- [Stalker](https://www.frida.re/docs/javascript-api/#stalker)：如果您的跟踪要求包括透明度、性能和高粒度，Stalker 应该是您的 API 之选。当使用 Stalker API 跟踪代码时，Frida 利用即时动态重新编译（通过使用[Capstone](http://www.capstone-engine.org/)）：当线程即将执行其下一条指令时，Stalker 分配一些内存，复制原始代码，并将副本与您的仪器自定义代码。最后，它执行复制（保持原始代码不变，从而避免任何反调试检查）。这种方法大大提高了检测性能，并在跟踪时允许非常高的粒度（例如，通过专门跟踪 CALL 或 RET 指令）。您可以在Frida 的创建者 Ole [#vadla][的博客文章“代码跟踪器剖析”。](https://medium.com/@oleavr/anatomy-of-a-code-tracer-b081aadb0df8)Stalker 的一些使用示例是，例如[who-does-it-call](https://codeshare.frida.re/@oleavr/who-does-it-call/)或[diff-calls](https://github.com/frida/frida-presentations/blob/master/R2Con2017/01-basics/02-diff-calls.js)。
- [Java](https://www.frida.re/docs/javascript-api/#java)：在 Android 上工作时，您可以使用此 API 枚举已加载的类、枚举类加载器、创建和使用特定类实例、通过扫描堆枚举类的活动实例等。
- [ObjC](https://www.frida.re/docs/javascript-api/#objc)：在 iOS 上工作时，您可以使用此 API 获取所有已注册类的映射、注册或使用特定类或协议实例、通过扫描堆枚举类的活动实例等。

Frida 还提供了一些构建在 Frida API 之上的简单工具，在通过 pip 安装 frida-tools 后可以直接从终端使用。例如：

- 您可以使用[Frida CLI](https://www.frida.re/docs/frida-cli/) ( `frida`) 进行快速脚本原型设计和尝试/错误场景。
- [`frida-ps`](https://www.frida.re/docs/frida-ps/)获取设备上运行的所有应用程序（或进程）的列表，包括它们的名称、标识符和 PID。
- [`frida-ls-devices`](https://www.frida.re/docs/frida-ls-devices/)列出运行 Frida 服务器或代理的已连接设备。
- [`frida-trace`](https://www.frida.re/docs/frida-trace/)快速跟踪作为 iOS 应用程序的一部分或在 Android Native库(NATIVE LIBRARIES)中实现的方法。

此外，您还会发现几个基于 Frida 的开源工具，例如：

- [Passionfruit](https://github.com/chaitin/passionfruit)：iOS 应用程序黑盒评估工具。
- [Fridump](https://github.com/Nightbringer21/fridump)：适用于 Android 和 iOS 的内存转储工具。
- [objection](https://github.com/sensepost/objection)：一个Runtime(运行时)移动安全评估框架。
- [r2frida](https://github.com/nowsecure/r2frida)：一个将 radare2 强大的逆向工程能力与 Frida 的动态检测工具包相结合的项目。
- [jnitrace](https://github.com/chame1eon/jnitrace)：一种用于跟踪Native库(NATIVE LIBRARIES)对 Android JNI Runtime(运行时)方法的使用情况的工具。

我们将在整个指南中使用所有这些工具。

您可以按原样使用这些工具，根据您的需要调整它们，或者作为如何使用 API 的优秀示例。当您编写自己的Hook脚本或构建内省工具以支持您的逆向工程工作流时，将它们作为示例非常有帮助。

#### Android版Frida[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-for-android)

Frida 支持通过[Java API](https://www.frida.re/docs/javascript-api/#java)与 Android Java Runtime(运行时)交互。您将能够在进程及其Native库(NATIVE LIBRARIES)中Hook和调用 Java 和Native函数。您的 JavaScript 代码段可以完全访问内存，例如读取和/或写入任何结构化数据。

以下是 Frida API 提供的一些任务，这些任务在 Android 上是相关的或独有的：

- 实例化 Java 对象并调用静态和非静态类方法 ( [Java API](https://www.frida.re/docs/javascript-api/#java) )。
- 替换 Java 方法实现 ( [Java API](https://www.frida.re/docs/javascript-api/#java) )。
- [通过扫描 Java 堆 ( Java API](https://www.frida.re/docs/javascript-api/#java) )枚举特定类的实时实例。
- 扫描进程内存中出现的字符串 ( [Memory API](https://www.frida.re/docs/javascript-api/#memory) )。
- 拦截Native函数调用以在函数入口和出口处运行您自己的代码 ( [Interceptor API](https://www.frida.re/docs/javascript-api/#interceptor) )。

请记住，在 Android 上，您还可以受益于安装 Frida 时提供的内置工具，其中包括 Frida CLI ( `frida`)、`frida-ps`和`frida-ls-devices`，`frida-trace`仅举几例。

人们经常将 Frida 与 Xposed 进行比较，但这种比较远非公平，因为这两个框架的设计目标不同。作为应用程序安全测试人员，了解这一点很重要，这样您就可以知道在哪种情况下使用哪种框架：

- Frida 是独立的，您只需从目标 Android 设备的已知位置运行 frida-server 二进制文件（请参阅下面的“安装 Frida”）。这意味着，与 Xposed 相比，它没有*深入*安装在目标操作系统中。
- 逆向应用程序是一个迭代过程。作为前一点的结果，您在测试时获得更短的反馈循环，因为您不需要（软）重启来应用或简单地更新您的Hook。因此，在实现更永久的Hook时，您可能更愿意使用 Xposed。
- 你可以在你的进程运行期间的任何时候动态地注入和更新你的 Frida JavaScript 代码（类似于 iOS 上的 Cycript）。通过这种方式，您可以通过让 Frida 生成您的应用程序来执行所谓的*早期检测*，或者您可能更愿意附加到您可能已进入特定状态的正在运行的应用程序。
- Frida 能够处理 Java 和Native代码 (JNI)，允许您修改它们。不幸的是，这是缺乏Native代码支持的 Xposed 的局限性。

> 请注意，截至 2019 年初，Xposed 还不适用于 Android 9（API 级别 28）。

##### 在 ANDROID 上安装 FRIDA[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#installing-frida-on-android)

为了在您的 Android 设备上设置 Frida：

- 如果你的设备没有root，你也可以使用Frida，请参考“逆向工程和篡改”章节的“[非root设备的动态分析”部分。](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/#dynamic-analysis-on-non-rooted-devices)
- 如果您有 root 设备，只需按照[官方说明](https://www.frida.re/docs/android/)或以下提示操作即可。

除非另有说明，否则我们在这里假设有Root设备。从[Frida 发布页面](https://github.com/frida/frida/releases)下载 frida-server 二进制文件。确保为您的 Android 设备或模拟器的架构下载正确的 frida-server 二进制文件：x86、x86_64、arm 或 arm64。确保服务器版本（至少是主版本号）与本地 Frida 安装的版本相匹配。PyPI 通常会安装最新版本的 Frida。如果不确定安装的是哪个版本，可以使用 Frida 命令行工具进行检查：

```
frida --version
```

或者您可以运行以下命令来自动检测 Frida 版本并下载正确的 frida-server 二进制文件：

```
wget https://github.com/frida/frida/releases/download/$(frida --version)/frida-server-$(frida --version)-android-arm.xz
```

将 frida-server 复制到设备并运行它：

```
adb push frida-server /data/local/tmp/
adb shell "chmod 755 /data/local/tmp/frida-server"
adb shell "su -c /data/local/tmp/frida-server &"
```

##### 在 ANDROID 上使用 FRIDA[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-frida-on-android)

随着 frida-server 的运行，您现在应该能够使用以下命令获取正在运行的进程列表（使用该`-U`选项指示 Frida 使用连接的 USB 设备或模拟器）：

```
$ frida-ps -U
  PID  Name
-----  --------------------------------------------------------------
  276  adbd
  956  android.process.media
  198  bridgemgrd
30692  com.android.chrome
30774  com.android.chrome:privileged_process0
30747  com.android.chrome:sandboxed
30834  com.android.chrome:sandboxed
 3059  com.android.nfc
 1526  com.android.phone
17104  com.android.settings
 1302  com.android.systemui
(...)
```

或者使用`-Uai`标志组合限制列表以获取连接的 USB 设备 ( ) 上`-a`当前安装的所有应用程序 ( )：`-i``-U`

```
$ frida-ps -Uai
  PID  Name                                      Identifier
-----  ----------------------------------------  ------------------------------
  766  Android System                            android
30692  Chrome                                    com.android.chrome
 3520  Contacts Storage                          com.android.providers.contacts
    -  Uncrackable1                              sg.vantagepoint.uncrackable1
    -  drozer Agent                              com.mwr.dz
```

这将显示所有应用程序的名称和标识符，如果它们当前正在运行，它还会显示它们的 PID。在列表中搜索您的应用程序并记下 PID 或其名称/标识符。从现在开始，您将使用其中一个来引用您的应用程序。建议使用标识符，因为 PID 会在应用程序的每次运行中发生变化。例如，让我们采取`com.android.chrome`。您现在可以在所有 Frida 工具上使用此字符串，例如在 Frida CLI、frida-trace 或 Python 脚本中。

##### 使用 FRIDA-TRACE 追踪原生库[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tracing-native-libraries-with-frida-trace)

要跟踪特定（低级）库调用，您可以使用`frida-trace`命令行工具：

```
frida-trace -U com.android.chrome -i "open"
```

这会在 中生成一些 JavaScript `__handlers__/libc.so/open.js`，Frida 将其注入到进程中。该脚本跟踪`open`对`libc.so`. 您可以根据需要使用 Frida [JavaScript API](https://www.frida.re/docs/javascript-api/)修改生成的脚本。

不幸的是，目前还不支持跟踪 Java 类的高级方法（但[将来](https://github.com/frida/frida-python/issues/70)可能会支持）。

##### FRIDA CLI 和 JAVA API[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-cli-and-the-java-api)

使用 Frida CLI 工具 ( `frida`) 以交互方式使用 Frida。它Hook到一个进程中，并为您提供 Frida API 的命令行界面。

```
frida -U com.android.chrome
```

通过该`-l`选项，您还可以使用 Frida CLI 加载脚本，例如加载`myscript.js`：

```
frida -U -l myscript.js com.android.chrome
```

Frida 还提供了一个[Java API](https://www.frida.re/docs/javascript-api/#java)，这对于处理 Android 应用程序特别有帮助。它使您可以直接使用 Java 类和对象。这是一个脚本来覆盖`onResume`Activity 类的功能：

```
Java.perform(function () {
    var Activity = Java.use("android.app.Activity");
    Activity.onResume.implementation = function () {
        console.log("[*] onResume() got called!");
        this.onResume();
    };
});
```

上面的脚本调用`Java.perform`以确保您的代码在 Java VM 的上下文中执行。`android.app.Activity`它通过实例化类的包装器`Java.use`并覆盖`onResume`函数。每次在应用程序中恢复活动时，新`onResume`函数实现都会向控制台打印通知并调用原始`onResume`方法。`this.onResume`

Frida 还允许您搜索和使用堆上的实例化对象。以下脚本搜索`android.view.View`对象的实例并调用它们的`toString`方法。结果打印到控制台：

```
setImmediate(function() {
    console.log("[*] Starting script");
    Java.perform(function () {
        Java.choose("android.view.View", {
             "onMatch":function(instance){
                  console.log("[*] Instance found: " + instance.toString());
             },
             "onComplete":function() {
                  console.log("[*] Finished heap search")
             }
        });
    });
});
```

输出将如下所示：

```
[*] Starting script
[*] Instance found: android.view.View{7ccea78 G.ED..... ......ID 0,0-0,0 #7f0c01fc app:id/action_bar_black_background}
[*] Instance found: android.view.View{2809551 V.ED..... ........ 0,1731-0,1731 #7f0c01ff app:id/menu_anchor_stub}
[*] Instance found: android.view.View{be471b6 G.ED..... ......I. 0,0-0,0 #7f0c01f5 app:id/location_bar_verbose_status_separator}
[*] Instance found: android.view.View{3ae0eb7 V.ED..... ........ 0,0-1080,63 #102002f android:id/statusBarBackground}
[*] Finished heap search
```

您还可以使用 Java 的反射功能。要列出`android.view.View`类的公共方法，您可以在 Frida 中为此类创建一个包装器并`getMethods`从包装器的`class`属性中调用：

```
Java.perform(function () {
    var view = Java.use("android.view.View");
    var methods = view.class.getMethods();
    for(var i = 0; i < methods.length; i++) {
        console.log(methods[i].toString());
    }
});
```

这将向终端打印一长串方法：

```
public boolean android.view.View.canResolveLayoutDirection()
public boolean android.view.View.canResolveTextAlignment()
public boolean android.view.View.canResolveTextDirection()
public boolean android.view.View.canScrollHorizontally(int)
public boolean android.view.View.canScrollVertically(int)
public final void android.view.View.cancelDragAndDrop()
public void android.view.View.cancelLongPress()
public final void android.view.View.cancelPendingInputEvents()
...
```

#### iOS 版Frida[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-for-ios)

Frida 支持通过[ObjC API](https://www.frida.re/docs/javascript-api/#objc)与 Objective-C Runtime(运行时)交互。您将能够在进程及其Native库(NATIVE LIBRARIES)中Hook和调用 Objective-C 和Native函数。您的 JavaScript 代码段可以完全访问内存，例如读取和/或写入任何结构化数据。

以下是 Frida API 提供的一些任务，这些任务在 iOS 上是相关的或独有的：

- 实例化 Objective-C 对象并调用静态和非静态类方法 ( [ObjC API](https://www.frida.re/docs/javascript-api/#objc) )。
- 跟踪 Objective-C 方法调用和/或替换它们的实现（[拦截器 API](https://www.frida.re/docs/javascript-api/#interceptor)）。
- [通过扫描堆 ( ObjC API](https://www.frida.re/docs/javascript-api/#objc) )枚举特定类的实时实例。
- 扫描进程内存中出现的字符串 ( [Memory API](https://www.frida.re/docs/javascript-api/#memory) )。
- 拦截Native函数调用以在函数入口和出口处运行您自己的代码 ( [Interceptor API](https://www.frida.re/docs/javascript-api/#interceptor) )。

请记住，在 iOS 上，您还可以受益于安装 Frida 时提供的内置工具，其中包括 Frida CLI ( `frida`)、`frida-ps`和`frida-ls-devices`等等`frida-trace`。

iOS 上有一项`frida-trace`独有的功能值得强调：使用`-m`标志和通配符跟踪 Objective-C API。例如，跟踪名称中包含“HTTP”并属于名称以“NSURL”开头的任何类的所有方法就像运行一样简单：

```
frida-trace -U YourApp -m "*[NSURL* *HTTP*]"
```

要快速入门，您可以查看[iOS 示例](https://www.frida.re/docs/examples/ios/)。

##### 在 IOS 上安装 FRIDA[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#installing-frida-on-ios)

要将 Frida 连接到 iOS 应用程序，您需要一种方法将 Frida Runtime(运行时)注入该应用程序。这在越狱设备上很容易做到：只需`frida-server`通过 Cydia 安装即可。安装后，Frida 服务器将自动以 root 权限运行，让您可以轻松地将代码注入任何进程。

**启动 Cydia 并通过导航到管理**->**源**->**编辑**->**添加**并输入[https://build.frida.re](https://build.frida.re/)添加 Frida 的存储库。然后你应该能够找到并安装 Frida 包。

##### 在 IOS 上使用 FRIDA[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-frida-on-ios)

`frida-ps`通过 USB 连接您的设备，并通过运行命令和标志“-U”确保 Frida 正常工作。这应该返回设备上运行的进程列表：

```
$ frida-ps -U
PID  Name
---  ----------------
963  Mail
952  Safari
416  BTServer
422  BlueTool
791  CalendarWidget
451  CloudKeychainPro
239  CommCenter
764  ContactsCoreSpot
(...)
```

#### Frida绑定[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-bindings)

为了扩展脚本体验，Frida 提供了与 Python、C、NodeJS 和 Swift 等编程语言的绑定。

以 Python 为例，首先要注意的是不需要进一步的安装步骤。启动您的 Python 脚本，`import frida`您就可以开始了。请参阅以下仅运行前面的 JavaScript 代码段的脚本：

```
# frida_python.py
import frida

session = frida.get_usb_device().attach('com.android.chrome')

source = """
Java.perform(function () {
    var view = Java.use("android.view.View");
    var methods = view.class.getMethods();
    for(var i = 0; i < methods.length; i++) {
        console.log(methods[i].toString());
    }
});
"""

script = session.create_script(source)
script.load()

session.detach()
```

在这种情况下，运行 Python 脚本 ( `python3 frida_python.py`) 与前面的示例具有相同的结果：它将`android.view.View`类的所有方法打印到终端。但是，您可能希望使用来自 Python 的数据。使用`send`instead of`console.log`会将 JSON 格式的数据从 JavaScript 发送到 Python。请阅读以下示例中的注释：

```
# python3 frida_python_send.py
import frida

session = frida.get_usb_device().attach('com.android.chrome')

# 1. we want to store method names inside a list
android_view_methods = []

source = """
Java.perform(function () {
    var view = Java.use("android.view.View");
    var methods = view.class.getMethods();
    for(var i = 0; i < methods.length; i++) {
        send(methods[i].toString());
    }
});
"""

script = session.create_script(source)

# 2. this is a callback function, only method names containing "Text" will be appended to the list
def on_message(message, data):
    if "Text" in message['payload']:
        android_view_methods.append(message['payload'])

# 3. we tell the script to run our callback each time a message is received
script.on('message', on_message)

script.load()

# 4. we do something with the collected data, in this case we just print it
for method in android_view_methods:
    print(method)

session.detach()
```

这有效地过滤了方法并仅打印包含字符串“Text”的方法：

```
$ python3 frida_python_send.py
public boolean android.view.View.canResolveTextAlignment()
public boolean android.view.View.canResolveTextDirection()
public void android.view.View.setTextAlignment(int)
public void android.view.View.setTextDirection(int)
public void android.view.View.setTooltipText(java.lang.CharSequence)
...
```

最后，由您决定在何处使用数据。有时使用 JavaScript 会更方便，而在其他情况下，Python 将是最佳选择。当然，您也可以使用`script.post`. 有关[发送](https://www.frida.re/docs/messages/#sending-messages-from-a-target-process)和[接收](https://www.frida.re/docs/messages/#receiving-messages-in-a-target-process)消息的更多信息，请参阅 Frida 文档。

### Frida代码共享[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-codeshare)

[Frida CodeShare](https://codeshare.frida.re/)是一个存储库，包含一组随时可以运行的 Frida 脚本，这些脚本在 Android 和 iOS 上执行具体任务时可以提供极大的帮助，也可以作为构建您自己的脚本的灵感。两个有代表性的例子是：

- 使用 Frida 的通用 Android SSL 固定绕过 - https://codeshare.frida.re/@pcipolloni/universal-android-ssl-pinning-bypass-with-frida/
- ObjC 方法观察者 - https://codeshare.frida.re/@mrmacete/objc-method-observer/

`--codeshare <handler>`使用它们就像使用 Frida CLI 时包含标志和处理程序一样简单。例如，要使用“ObjC 方法观察者”，请输入以下内容：

```
frida --codeshare mrmacete/objc-method-observer -f YOUR_BINARY
```

### Ghidra[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#ghidra)

Ghidra 是由美国国家安全局 (NSA) 研究理事会开发的开源软件逆向工程 (SRE) 工具套件。Ghidra 是一种多功能工具，由反汇编器、反编译器和用于高级用途的内置脚本引擎组成。请参阅有关如何安装它的[安装指南，并查看](https://ghidra-sre.org/InstallationGuide.html)[备忘单](https://ghidra-sre.org/CheatSheet.html)以获得可用命令和快捷方式的初步概述。在本节中，我们将逐步介绍如何创建项目、查看二进制文件的反汇编和反编译代码。

`ghidraRun`使用(*nix) 或(Windows)启动 Ghidra `ghidraRun.bat`，具体取决于您所在的平台。Ghidra 启动后，通过指定项目目录创建一个新项目。您将看到一个如下所示的窗口：

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_new_project.png)

在您的新**活动项目**中，您可以通过转到**文件**->**导入文件**并选择所需的文件来导入应用程序二进制文件。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_import_binary.png)

如果可以正确处理文件，Ghidra 将在开始分析之前显示有关二进制文件的元信息。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_elf_import.png)

要获取上面选择的二进制文件的反汇编代码，请双击“**活动项目”**窗口中的导入文件。单击**是**并**分析**以在后续窗口中进行自动分析。自动分析将需要一些时间，具体取决于二进制文件的大小，可以在代码浏览器窗口的右下角跟踪进度。自动分析完成后，您可以开始探索二进制文件。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_main_window.png)

在 Ghidra 中探索二进制文件的最重要的窗口是**列表**（反汇编）窗口、**符号树**窗口和**反编译**器窗口，它显示了为反汇编选择的函数的反编译版本。**Display Function Graph**选项显示所选函数的控制流图。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_function_graph.png)

Ghidra 中还有许多其他可用功能，其中大部分功能都可以通过打开“**窗口**”菜单进行探索。例如，如果要检查二进制文件中存在的字符串，请打开“**定义的字符串**”选项。在接下来的章节中，我们将讨论其他高级功能，同时分析适用于 Android 和 iOS 平台的各种二进制文件。

![img](https://mas.owasp.org/assets/Images/Chapters/0x04c/Ghidra_string_window.png)

### Hopper（商业工具）[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#hopper-commercial-tool)

用于 macOS 和 Linux 的逆向工程工具，用于反汇编、反编译和调试 32/64 位英特尔 Mac、Linux、Windows 和 iOS 可执行文件 - https://www.hopperapp.com/

### IDA Pro（商业工具）[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#ida-pro-commercial-tool)

Windows、Linux 或 macOS 托管的多处理器反汇编程序和调试器 - https://www.hex-rays.com/products/ida/index.shtml

### LIEF[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#lief)

LIEF 的目的是提供一个跨平台库来解析、修改和抽象 ELF、PE 和 MachO 格式。例如，使用它，您可以将某个库作为Native库(NATIVE LIBRARIES)的依赖项注入，应用程序默认情况下已经加载了该库。- https://lief.quarkslab.com/

### MobSF[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#mobsf)

[MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF)（移动安全框架）是一种自动化的一体化移动应用程序渗透测试框架，能够执行静态和动态分析。启动 MobSF 的最简单方法是通过 Docker。

```
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
```

或者通过运行以下命令在主机上本地安装并启动它：

```
# Setup
git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git
cd Mobile-Security-Framework-MobSF
./setup.sh # For Linux and Mac
setup.bat # For Windows

# Installation process
./run.sh # For Linux and Mac
run.bat # For Windows
```

MobSF 启动并运行后，您可以在浏览器中导航至[http://127.0.0.1:8000](http://127.0.0.1:8000/)打开它。只需将您要分析的 APK 拖到上传区域，MobSF 就会开始它的工作。

#### Android 版 MobSF[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#mobsf-for-android)

MobSF 完成分析后，您将收到一份包含所有已执行测试的一页概述。该页面分为多个部分，提供了有关应用程序攻击面的一些初步提示。

![img](https://mas.owasp.org/assets/Images/Chapters/0x05b/mobsf_android.png)

显示如下：

- 有关应用程序及其二进制文件的基本信息。
- 一些选项：
- 查看`AndroidManifest.xml`文件。
- 查看应用程序的 IPC 组件。
- 签名者证书。
- 应用权限。
- 显示已知缺陷的安全分析，例如，如果应用程序备份已启用。
- 应用程序二进制文件使用的库列表和解压缩的 APK 中的所有文件列表。
- 检查恶意 URL 的恶意软件分析。

有关详细信息，请参阅[MobSF 文档](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/1.-Documentation)。

#### 适用于 iOS 的 MobSF[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#mobsf-for-ios)

通过在 macOS 主机上本地运行 MobSF，您将受益于稍微更好的类转储输出。

MobSF 启动并运行后，您可以在浏览器中导航至[http://127.0.0.1:8000](http://127.0.0.1:8000/)打开它。只需将您要分析的 IPA 拖到上传区域，MobSF 就会开始工作。

MobSF 完成分析后，您将收到一份包含所有已执行测试的一页概述。该页面分为多个部分，提供了有关应用程序攻击面的一些初步提示。

![img](https://mas.owasp.org/assets/Images/Chapters/0x06b/mobsf_ios.png)

显示如下：

- 有关应用程序及其二进制文件的基本信息。
- 一些选项：
- 查看`Info.plist`文件。
- 查看应用程序二进制文件中包含的字符串。
- 下载类转储，如果应用程序是用 Objective-C 编写的；如果它是用 Swift 编写的，则无法创建类转储。
- 列出从中提取的所有目的字符串，`Info.plist`其中提供了有关应用程序权限的一些提示。
- 将列出 App Transport Security (ATS) 配置中的例外情况。
- 一个简短的二进制分析，显示是否激活了免费的二进制安全功能，或者例如二进制是否使用了被禁止的 API。
- 应用程序二进制文件使用的库列表和解压缩的 IPA 中的所有文件列表。

> 与 Android 用例相反，MobSF 不为 iOS 应用程序提供任何动态分析功能。

有关详细信息，请参阅[MobSF 文档](https://mobsf.github.io/docs)。

### nm[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#nm)

nm 是一种显示给定二进制文件名称列表（符号表）的工具。您可以找到有关[Android (GNU)](https://ftp.gnu.org/old-gnu/Manuals/binutils-2.12/html_node/binutils_4.html)版本和[iOS](https://www.manpagez.com/man/1/nm/osx-10.12.6.php)的更多信息。

### objection[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#objection)

[Objection](https://github.com/sensepost/objection)是一个“由 Frida 提供支持的Runtime(运行时)移动探索工具包”。它的主要目标是允许通过直观的界面在非 root 设备上进行安全测试。

Objection 通过为您提供工具以通过重新打包将 Frida 小工具轻松注入应用程序来实现此目标。这样，您可以通过旁加载将重新打包的应用程序部署到非 root/非越狱设备。Objection 还提供了一个 REPL，允许您与应用程序交互，使您能够执行应用程序可以执行的任何操作。

Objection 可以通过 pip 安装，如[Objection's Wiki](https://github.com/sensepost/objection/wiki/Installation)中所述。

```
pip3 install objection
```

#### Android objection[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#objection-for-android)

Objection 提供了几个特定于 Android 的功能。您可以在项目页面上找到[完整的功能列表](https://github.com/sensepost/objection/wiki/Features)，但这里有一些有趣的功能：

- 重新打包应用程序以包含 Frida 小工具
- 为流行的方法禁用 SSL 固定
- 访问应用程序存储以下载或上传文件
- 执行自定义 Frida 脚本
- 列出活动、服务和广播接收器
- 开始活动

如果你有一台安装了 frida-server 的 root 设备，Objection 可以直接连接到正在运行的 Frida 服务器以提供其所有功能，而无需重新打包应用程序。然而，Android 设备并不总是能够 root，或者应用程序可能包含用于 root 检测的高级 RASP 控件，因此注入 frida-gadget 可能是绕过这些控件的最简单方法。

**在非 Root 设备上执行高级动态分析**的能力是使 Objection 非常有用的功能之一。遵循[重新打包过程](https://mas.owasp.org/MASTG/Android/0x05b-Basic-Security_Testing/#repackaging-apps)后，您将能够运行上述所有命令，这使得快速分析应用程序或绕过基本安全控制变得非常容易。

##### 在 ANDROID 上使用objection[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-objection-on-android)

启动 Objection 取决于您是否已修补 APK 或您是否使用运行 Frida-server 的 root 设备。对于运行已打补丁的 APK，对象将自动查找所有连接的设备并搜索监听的 Frida 小工具。但是，在使用 frida-server 时，你需要明确地告诉 frida-server 你要分析哪个应用程序。

```
# Connecting to a patched APK
objection explore

# Find the correct name using frida-ps
$ frida-ps -Ua | grep -i telegram
30268  Telegram                               org.telegram.messenger

# Connecting to the Telegram app through Frida-server
$ objection --gadget="org.telegram.messenger" explore
```

进入 Objection REPL 后，您可以执行任何可用的命令。以下是一些最有用的概述：

```
# Show the different storage locations belonging to the app
$ env

# Disable popular ssl pinning methods
$ android sslpinning disable

# List items in the keystore
$ android keystore list

# Try to circumvent root detection
$ android root disable
```

可以在[Objection Wiki上找到有关使用 Objective REPL 的更多信息](https://github.com/sensepost/objection/wiki/Using-objection)

#### 针对 iOS 的objection[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#objection-for-ios)

Objective 提供了几个特定于 iOS 的功能。您可以在项目页面上找到[完整的功能列表](https://github.com/sensepost/objection/wiki/Features)，但这里有一些有趣的功能：

- 重新打包应用程序以包含 Frida 小工具
- 为流行的方法禁用 SSL 固定
- 访问应用程序存储以下载或上传文件
- 执行自定义 Frida 脚本
- 转储钥匙串
- 读取 plist 文件

所有这些任务以及更多任务都可以通过使用 objection 的 REPL 中的命令轻松完成。例如，您可以通过运行以下命令获取应用程序中使用的类、类的功能或有关应用程序的 bundle 的信息：

```
OWASP.iGoat-Swift on (iPhone: 12.0) [usb] # ios hooking list classes
OWASP.iGoat-Swift on (iPhone: 12.0) [usb] # ios hooking list class_methods <ClassName>
OWASP.iGoat-Swift on (iPhone: 12.0) [usb] # ios bundles list_bundles
```

如果你有安装了 frida-server 的越狱设备，Objection 可以直接连接到正在运行的 Frida 服务器以提供其所有功能，而无需重新打包应用程序。但是，并非总是可以越狱最新版本的 iOS，或者您的应用程序可能具有高级越狱检测机制。

**在非越狱设备上执行高级动态分析**的能力是使 Objection 非常有用的功能之一。遵循[重新打包过程](https://mas.owasp.org/MASTG/iOS/0x06b-Basic-Security-Testing/#repackaging-apps)后，您将能够运行上述所有命令，这使得快速分析应用程序或绕过基本安全控制变得非常容易。

##### 在 IOS 上使用objection[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-objection-on-ios)

启动 Objection 取决于您是否已修补 IPA 或您是否使用运行 Frida-server 的越狱设备。对于运行已打补丁的 IPA，objection将自动查找任何连接的设备并搜索正在监听的 Frida 小工具。但是，在使用 frida-server 时，你需要明确地告诉 frida-server 你要分析哪个应用程序。

```
# Connecting to a patched IPA
$ objection explore

# Using frida-ps to get the correct application name
$ frida-ps -Ua | grep -i Telegram
983  Telegram

# Connecting to the Telegram app through Frida-server
$ objection --gadget="Telegram" explore
```

进入 Objection REPL 后，您可以执行任何可用的命令。以下是一些最有用的概述：

```
# Show the different storage locations belonging to the app
$ env

# Disable popular ssl pinning methods
$ ios sslpinning disable

# Dump the Keychain
$ ios keychain dump

# Dump the Keychain, including access modifiers. The result will be written to the host in myfile.json
$ ios keychain dump --json <myfile.json>

# Show the content of a plist file
$ ios plist cat <myfile.plist>
```

可以在[Objection Wiki上找到有关使用 Objective REPL 的更多信息](https://github.com/sensepost/objection/wiki/Using-objection)

### r2Frida[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#r2frida)

[r2frida](https://github.com/nowsecure/r2frida)是一个让radare2 连接到Frida 的项目，有效地将radare2 强大的逆向工程能力与Frida 的动态检测工具包结合起来。r2frida 可以在 Android 和 iOS 上使用，允许您：

- 通过 USB 或 TCP 将 radare2 附加到任何本地进程或远程 frida-server。
- 从目标进程读取/写入内存。
- 将地图、符号、导入、类和方法等 Frida 信息加载到 radare2 中。
- 从 Frida 调用 r2 命令，因为它向 Frida Javascript API 公开了 r2pipe 接口。

请参考[r2frida官方安装说明](https://github.com/nowsecure/r2frida/blob/master/README.md#installation)。

随着 frida-server 的运行，您现在应该能够使用 pid、spawn 路径、主机和端口或设备 ID 附加到它。例如，附加到 PID 1234：

```
r2 frida://1234
```

有关如何连接到 frida-server 的更多示例，[请参阅 r2frida 的 README 页面中的使用部分](https://github.com/nowsecure/r2frida/blob/master/README.md#usage)。

> 以下示例是使用 Android 应用程序执行的，但也适用于 iOS 应用程序。

`\`一旦进入 r2frida 会话，所有命令都以或开头`=!`。例如，在 radare2 中你会运行`i`以显示二进制信息，但在 r2frida 中你会使用`\i`.

> 查看所有选项`r2 frida://?`。

```
[0x00000000]> \i
arch                x86
bits                64
os                  linux
pid                 2218
uid                 1000
objc                false
runtime             V8
java                false
cylang              false
pageSize            4096
pointerSize         8
codeSigningPolicy   optional
isDebuggerAttached  false
```

要在内存中搜索特定关键字，您可以使用搜索命令`\/`：

```
[0x00000000]> \/ unacceptable
Searching 12 bytes: 75 6e 61 63 63 65 70 74 61 62 6c 65
Searching 12 bytes in [0x0000561f05ebf000-0x0000561f05eca000]
...
Searching 12 bytes in [0xffffffffff600000-0xffffffffff601000]
hits: 23
0x561f072d89ee hit12_0 unacceptable policyunsupported md algorithmvar bad valuec
0x561f0732a91a hit12_1 unacceptableSearching 12 bytes: 75 6e 61 63 63 65 70 74 61
```

要以 JSON 格式输出搜索结果，我们只需添加`j`到我们之前的搜索命令（就像我们在 r2 shell 中所做的那样）。这可以在大多数命令中使用：

```
[0x00000000]> \/j unacceptable
Searching 12 bytes: 75 6e 61 63 63 65 70 74 61 62 6c 65
Searching 12 bytes in [0x0000561f05ebf000-0x0000561f05eca000]
...
Searching 12 bytes in [0xffffffffff600000-0xffffffffff601000]
hits: 23
{"address":"0x561f072c4223","size":12,"flag":"hit14_1","content":"unacceptable \
policyunsupported md algorithmvar bad valuec0"},{"address":"0x561f072c4275", \
"size":12,"flag":"hit14_2","content":"unacceptableSearching 12 bytes: 75 6e 61 \
63 63 65 70 74 61"},{"address":"0x561f072c42c8","size":12,"flag":"hit14_3", \
"content":"unacceptableSearching 12 bytes: 75 6e 61 63 63 65 70 74 61 "},
...
```

要列出加载的库，请使用命令`\il`并使用来自 radare2 的内部 grep 和命令过滤结果`~`。例如，以下命令将列出匹配关键字`keystore`,`ssl`和的已加载库`crypto`：

```
[0x00000000]> \il~keystore,ssl,crypto
0x00007f3357b8e000 libssl.so.1.1
0x00007f3357716000 libcrypto.so.1.1
```

同样，要列出导出并按特定关键字过滤结果：

```
[0x00000000]> \iE libssl.so.1.1~CIPHER
0x7f3357bb7ef0 f SSL_CIPHER_get_bits
0x7f3357bb8260 f SSL_CIPHER_find
0x7f3357bb82c0 f SSL_CIPHER_get_digest_nid
0x7f3357bb8380 f SSL_CIPHER_is_aead
0x7f3357bb8270 f SSL_CIPHER_get_cipher_nid
0x7f3357bb7ed0 f SSL_CIPHER_get_name
0x7f3357bb8340 f SSL_CIPHER_get_auth_nid
0x7f3357bb7930 f SSL_CIPHER_description
0x7f3357bb8300 f SSL_CIPHER_get_kx_nid
0x7f3357bb7ea0 f SSL_CIPHER_get_version
0x7f3357bb7f10 f SSL_CIPHER_get_id
```

要列出或设置断点，请使用命令 db。这在分析/修改内存时很有用：

```
[0x00000000]> \db
```

最后，请记住，您还可以通过`\.`加上脚本名称来运行 Frida JavaScript 代码：

```
[0x00000000]> \. agent.js
```

您可以在他们的 Wiki 项目中找到更多关于[如何使用 r2frida的示例。](https://github.com/enovella/r2frida-wiki)

### RADARE2[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#radare2)

#### radare2 (Android)[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#radare2-android)

[radare2](https://rada.re/r/) (r2) 是一种流行的开源逆向工程框架，用于反汇编、调试、修补和分析二进制文件，可编写脚本并支持许多体系结构和文件格式，包括 Android 和 iOS 应用程序。对于 Android，支持 Dalvik DEX（odex、multidex）、ELF（可执行文件、.so、ART）和 Java（JNI 和 Java 类）。它还包含几个有用的脚本，可以在移动应用程序分析过程中为您提供帮助，因为它提供了低级别的反汇编和安全的静态分析，当传统工具失败时可以派上用场。

radare2 实现了丰富的命令行界面 (CLI)，您可以在其中执行上述任务。但是，如果您不太习惯使用 CLI 进行逆向工程，您可能需要考虑使用 Web UI（通过`-H`标志）或更方便的 Qt 和 C++ GUI 版本[Cutter](https://github.com/radareorg/cutter)。请记住，CLI，更具体地说，它的可视化模式和脚本功能 ( [r2pipe](https://github.com/radare/radare2-r2pipe) )，是 radare2 强大功能的核心，绝对值得学习如何使用它。

##### 安装 RADARE2[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#installing-radare2)

请参考[radare2的官方安装说明](https://github.com/radare/radare2/blob/master/README.md)。我们强烈建议始终从 GitHub 版本安装 radare2，而不是通过 APT 等常见的包管理器。Radare2 的开发非常活跃，这意味着第三方存储库经常过时。

##### 使用 RADARE2[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-radare2)

radare2 框架包含一组小型实用程序，可以从 r2 shell 使用或作为 CLI 工具独立使用。这些实用程序包括`rabin2`, `rasm2`, `rahash2`, `radiff2`, `rafind2`, `ragg2`, `rarun2`, `rax2`, 当然还有`r2`, 这是主要的。

例如，您可以使用`rafind2`直接从编码的 Android 清单 (AndroidManifest.xml) 中读取字符串：

```
# Permissions
$ rafind2 -ZS permission AndroidManifest.xml
# Activities
$ rafind2 -ZS activity AndroidManifest.xml
# Content providers
$ rafind2 -ZS provider AndroidManifest.xml
# Services
$ rafind2 -ZS service AndroidManifest.xml
# Receivers
$ rafind2 -ZS receiver AndroidManifest.xml
```

或用于`rabin2`获取有关二进制文件的信息：

```
$ rabin2 -I UnCrackable-Level1/classes.dex
arch     dalvik
baddr    0x0
binsz    5528
bintype  class
bits     32
canary   false
retguard false
class    035
crypto   false
endian   little
havecode true
laddr    0x0
lang     dalvik
linenum  false
lsyms    false
machine  Dalvik VM
maxopsz  16
minopsz  1
nx       false
os       linux
pcalign  0
pic      false
relocs   false
sanitiz  false
static   true
stripped false
subsys   java
va       true
sha1  12-5508c  b7fafe72cb521450c4470043caa332da61d1bec7
adler32  12-5528c  00000000
```

键入`rabin2 -h`以查看所有选项：

```
$ rabin2 -h
Usage: rabin2 [-AcdeEghHiIjlLMqrRsSUvVxzZ] [-@ at] [-a arch] [-b bits] [-B addr]
              [-C F:C:D] [-f str] [-m addr] [-n str] [-N m:M] [-P[-P] pdb]
              [-o str] [-O str] [-k query] [-D lang symname] file
 -@ [addr]       show section, symbol or import at addr
 -A              list sub-binaries and their arch-bits pairs
 -a [arch]       set arch (x86, arm, .. or <arch>_<bits>)
 -b [bits]       set bits (32, 64 ...)
 -B [addr]       override base address (pie bins)
 -c              list classes
 -cc             list classes in header format
 -H              header fields
 -i              imports (symbols imported from libraries)
 -I              binary info
 -j              output in json
 ...
```

使用 main`r2`实用程序访问**r2 shell**。您可以像加载任何其他二进制文件一样加载 DEX 二进制文件：

```
r2 classes.dex
```

输入`r2 -h`以查看所有可用选项。一个非常常用的标志是`-A`，它在加载目标二进制文件后触发分析。但是，这应该谨慎使用并与小型二进制文件一起使用，因为它非常耗时和资源。[您可以在“ Android 上的篡改和逆向工程](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/)”一章中了解更多相关信息。

一旦进入 r2 shell，您还可以访问其他 radare2 实用程序提供的功能。例如，运行`i`将打印二进制文件的信息，与它完全一样`rabin2 -I`。

要打印所有字符串，请使用r2 shell 中的`rabin2 -Z`or 命令`iz`（或更简洁的命令`izq`）。

```
[0x000009c8]> izq
0xc50 39 39 /dev/com.koushikdutta.superuser.daemon/
0xc79 25 25 /system/app/Superuser.apk
...
0xd23 44 44 5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=
0xd51 32 32 8d127684cbc37c17616d806cf50473cc
0xd76 6 6 <init>
0xd83 10 10 AES error:
0xd8f 20 20 AES/ECB/PKCS7Padding
0xda5 18 18 App is debuggable!
0xdc0 9 9 CodeCheck
0x11ac 7 7 Nope...
0x11bf 14 14 Root detected!
```

大多数时候，您可以向命令附加特殊选项，例如`q`使命令不那么冗长（安静）或`j`以 JSON 格式提供输出（用于`~{}`美化 JSON 字符串）。

```
[0x000009c8]> izj~{}
[
  {
    "vaddr": 3152,
    "paddr": 3152,
    "ordinal": 1,
    "size": 39,
    "length": 39,
    "section": "file",
    "type": "ascii",
    "string": "L2Rldi9jb20ua291c2hpa2R1dHRhLnN1cGVydXNlci5kYWVtb24v"
  },
  {
    "vaddr": 3193,
    "paddr": 3193,
    "ordinal": 2,
    "size": 25,
    "length": 25,
    "section": "file",
    "type": "ascii",
    "string": "L3N5c3RlbS9hcHAvU3VwZXJ1c2VyLmFwaw=="
  },
```

`ic`您可以使用 r2 命令（*信息类*）打印类名及其方法。

```
[0x000009c8]> ic
...
0x0000073c [0x00000958 - 0x00000abc]    356 class 5 Lsg/vantagepoint/uncrackable1/MainActivity
:: Landroid/app/Activity;
0x00000958 method 0 pC   Lsg/vantagepoint/uncrackable1/MainActivity.method.<init>()V
0x00000970 method 1 P    Lsg/vantagepoint/uncrackable1/MainActivity.method.a(Ljava/lang/String;)V
0x000009c8 method 2 r    Lsg/vantagepoint/uncrackable1/MainActivity.method.onCreate (Landroid/os/Bundle;)V
0x00000a38 method 3 p    Lsg/vantagepoint/uncrackable1/MainActivity.method.verify (Landroid/view/View;)V
0x0000075c [0x00000acc - 0x00000bb2]    230 class 6 Lsg/vantagepoint/uncrackable1/a :: Ljava/lang/Object;
0x00000acc method 0 sp   Lsg/vantagepoint/uncrackable1/a.method.a(Ljava/lang/String;)Z
0x00000b5c method 1 sp   Lsg/vantagepoint/uncrackable1/a.method.b(Ljava/lang/String;)[B
```

您可以使用 r2 命令打印导入的方法`ii`（*信息导入*）。

```
[0x000009c8]> ii
[Imports]
Num  Vaddr       Bind      Type Name
...
  29 0x000005cc    NONE    FUNC Ljava/lang/StringBuilder.method.append(Ljava/lang/String;) Ljava/lang/StringBuilder;
  30 0x000005d4    NONE    FUNC Ljava/lang/StringBuilder.method.toString()Ljava/lang/String;
  31 0x000005dc    NONE    FUNC Ljava/lang/System.method.exit(I)V
  32 0x000005e4    NONE    FUNC Ljava/lang/System.method.getenv(Ljava/lang/String;)Ljava/lang/String;
  33 0x000005ec    NONE    FUNC Ljavax/crypto/Cipher.method.doFinal([B)[B
  34 0x000005f4    NONE    FUNC Ljavax/crypto/Cipher.method.getInstance(Ljava/lang/String;) Ljavax/crypto/Cipher;
  35 0x000005fc    NONE    FUNC Ljavax/crypto/Cipher.method.init(ILjava/security/Key;)V
  36 0x00000604    NONE    FUNC Ljavax/crypto/spec/SecretKeySpec.method.<init>([BLjava/lang/String;)V
```

检查二进制文件时的一种常见方法是搜索某些内容，导航到它并将其可视化以解释代码。使用 radare2 查找内容的方法之一是过滤特定命令的输出，即使用`~`加关键字（`~+`不区分大小写）来 grep 它们。例如，我们可能知道该应用程序正在验证某些内容，我们可以检查所有 radare2 标志并查看我们在哪里找到与“验证”相关的内容。

> 加载文件时，radare2 标记它能够找到的所有内容。这些标记的名称或引用称为标志。您可以通过命令访问它们`f`。

在这种情况下，我们将使用关键字“verify”对标志进行 grep：

```
[0x000009c8]> f~+verify
0x00000a38 132 sym.Lsg_vantagepoint_uncrackable1_MainActivity.method. \
verify_Landroid_view_View__V
0x00000a38 132 method.public.Lsg_vantagepoint_uncrackable1_MainActivity. \
Lsg_vantagepoint_uncrackable1
        _MainActivity.method.verify_Landroid_view_View__V
0x00001400 6 str.verify
```

似乎我们在 0x00000a38 中找到了一个方法（被标记了两次），在 0x00001400 中找到了一个字符串。让我们使用它的标志导航（寻找）到该方法：

```
[0x000009c8]> s sym.Lsg_vantagepoint_uncrackable1_MainActivity.method. \
verify_Landroid_view_View__V
```

当然，您也可以使用 r2 的反汇编程序功能并使用命令打印反汇编`pd`（或者`pdf`如果您知道您已经位于函数中）。

```
[0x00000a38]> pd
```

r2 命令通常接受选项（请参阅参考资料`pd?`），例如，您可以通过向命令附加一个数字（“N”）来限制显示的操作码`pd N`。

![img](https://mas.owasp.org/assets/Images/Chapters/0x05b/r2_pd_10.png)

除了将反汇编打印到控制台之外，您可能还想通过键入进入所谓的**可视模式**`V`。

![img](https://mas.owasp.org/assets/Images/Chapters/0x05b/r2_visualmode_hex.png)

默认情况下，您将看到十六进制视图。通过键入`p`您可以切换到不同的视图，例如反汇编视图：

![img](https://mas.owasp.org/assets/Images/Chapters/0x05b/r2_visualmode_disass.png)

Radare2 提供了一种**图形模式**，对于跟踪代码流非常有用。您可以通过键入以下内容从可视模式访问它`V`：

![img](https://mas.owasp.org/assets/Images/Chapters/0x05b/r2_graphmode.png)

这只是一些 radare2 命令的一部分，用于开始从 Android 二进制文件中获取一些基本信息。Radare2 非常强大，有几十个命令，您可以在[radare2 命令文档](https://book.rada.re/basic_commands/intro.html)中找到这些命令。Radare2 将在整个指南中用于不同的目的，例如逆向代码、调试或执行二进制分析。我们还将结合其他框架使用它，尤其是 Frida（有关更多信息，请参阅 r2frida 部分）。

请参阅“Android 上的[篡改和逆向工程](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/)”一章以了解 radare2 在 Android 上的更详细使用，尤其是在分析原生库时。您可能还想阅读[官方的 radare2 书籍](https://book.rada.re/)。

#### Radare2 (iOS)[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#radare2-ios)

[Radare2](https://github.com/radare/radare2)是一个用于逆向工程和分析二进制文件的完整框架。安装说明可以在 GitHub 存储库中找到。要了解更多关于 radare2 的信息，您可能需要阅读[radare2 官方书籍](https://book.rada.re/)。

### RMS Runtime(运行时)移动安全[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#rms-runtime-mobile-security)

[RMS - Runtime Mobile Security](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)是一个Runtime(运行时)移动应用程序分析工具包，支持 Android 和 iOS 应用程序。它提供了一个 web GUI 并且是用 Python 编写的。

它利用具有以下开箱即用功能的越狱设备上运行的 Frida 服务器：

- 执行流行的 Frida 脚本
- 执行自定义 Frida 脚本
- 转储所有加载的类和相关方法
- 动态Hook方法
- (Android) 监控Android API和原生API的使用

RMS 的安装说明和“操作指南”可以在[Github 存储库的自述文件中](https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security)找到。

## Android工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tools-for-android)

### ADB[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#adb)

[adb](https://developer.android.com/studio/command-line/adb) (Android Debug Bridge)，随 Android SDK 一起提供，在本地开发环境和连接的 Android 设备之间搭建桥梁。您通常会利用它在模拟器或通过 USB 或 Wi-Fi 连接的设备上测试应用程序。使用该`adb devices`命令列出连接的设备并使用`-l`参数执行它以检索有关它们的更多详细信息。

```
$ adb devices -l
List of devices attached
090c285c0b97f748 device usb:1-1 product:razor model:Nexus_7 device:flo
emulator-5554    device product:sdk_google_phone_x86 model:Android_SDK_built_for_x86 device:generic_x86 transport_id:1
```

adb 提供了其他有用的命令，例如`adb shell`在目标上启动交互式 shell 以及`adb forward`将特定主机端口上的流量转发到连接设备上的不同端口。

```
adb forward tcp:<host port> tcp:<device port>
$ adb -s emulator-5554 shell
root@generic_x86:/ # ls
acct
cache
charger
config
...
```

在本书后面的测试中，您将遇到有关如何使用 adb 命令的不同用例。请注意，如果连接了多个设备，则必须使用参数定义目标设备的序列号`-s`（如前面的代码片段所示）。

### AndroidNDK[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#android-ndk)

Android NDK 包含原生编译器和工具链的预构建版本。传统上支持 GCC 和 Clang 编译器，但对 GCC 的积极支持在 NDK 修订版 14 时结束。设备架构和主机操作系统决定了合适的版本。预构建的工具链位于`toolchains`NDK 的目录中，其中包含每个架构的一个子目录。

| 建筑学      | 工具链名称                           |
| :---------- | :----------------------------------- |
| 基于ARM     | arm-linux-androideabi-<gcc 版本>     |
| 基于 x86    | x86-<gcc 版本>                       |
| 基于 MIPS   | mipsel-linux-android-<gcc 版本>      |
| 基于ARM64   | aarch64-linux-android-<gcc 版本>     |
| 基于 X86-64 | x86_64-<gcc 版本>                    |
| 基于 MIPS64 | mips64el-linux-android-<gcc-version> |

除了选择正确的体系结构之外，您还需要为要定位的Native API 级别指定正确的 sysroot。sysroot 是一个包含目标系统头文件和库的目录。Native API 因 Android API 级别而异。每个 Android API 级别的可用 sysroot 目录可以在`$NDK/platforms/`. 每个 API 级目录都包含各种 CPU 和架构的子目录。

设置构建系统的一种可能性是将编译器路径和必要的标志导出为环境变量。然而，为了让事情变得更简单，NDK 允许您创建所谓的独立工具链，这是一个包含所需设置的临时工具链。

要设置独立的工具链，请下载[最新的稳定版本的 NDK](https://developer.android.com/ndk/downloads/index.html#stable-downloads)。解压缩 ZIP 文件，切换到 NDK 根目录，然后运行以下命令：

```
./build/tools/make_standalone_toolchain.py --arch arm --api 24 --install-dir /tmp/android-7-toolchain
```

这会在目录中为 Android 7.0（API 级别 24）创建一个独立的工具链`/tmp/android-7-toolchain`。为方便起见，您可以导出指向工具链目录的环境变量（我们将在示例中使用它）。运行以下命令或将其添加到您的`.bash_profile`或其他启动脚本中：

```
export TOOLCHAIN=/tmp/android-7-toolchain
```

### Android开发工具包[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#android-sdk)

本地 Android SDK 安装通过 Android Studio 进行管理。在 Android Studio 中创建一个空项目，然后选择**工具**-> **SDK 管理器**以打开 SDK 管理器 GUI。**SDK 平台**选项卡是您为多个 API 级别安装 SDK 的地方。最近的 API 级别是：

- Android 11.0（API 级别 30）
- Android 10.0（API 级别 29）
- Android 9.0（API 级别 28）
- Android 8.1（API 级别 27）
- Android 8.0（API 级别 26）

可以在[Android 开发者文档](https://source.android.com/setup/start/build-numbers)中找到所有 Android 代号、版本号和 API 级别的概述。

![img](https://mas.owasp.org/assets/Images/Chapters/0x05c/sdk_manager.jpg)

安装的 SDK 位于以下路径：

视窗：

```
C:\Users\<username>\AppData\Local\Android\sdk
```

苹果系统：

```
/Users/<username>/Library/Android/sdk
```

注意：在 Linux 上，您需要选择一个 SDK 目录。`/opt`, `/srv`, 和`/usr/local`是常见的选择。

### Android工作室[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#android-studio)

适用于 Google Android 操作系统的官方 IDE，基于 JetBrains 的 IntelliJ IDEA 软件构建，专为 Android 开发而设计 - https://developer.android.com/studio/index.html

### Android-SSL-TrustKiller[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#android-ssl-trustkiller)

Android-SSL-TrustKiller 是一个 Cydia Substrate 模块，充当黑盒工具，可以绕过设备上运行的大多数应用程序的 SSL 证书固定 - https://github.com/iSECPartners/Android-SSL-TrustKiller

### APKID[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#apkid)

[APKiD](https://github.com/rednaga/APKiD)为您提供有关如何制作 APK 的信息。它识别出许多编译器、加壳器、混淆器和其他奇怪的东西。

有关此工具的用途的更多信息，请查看：

- [Android 编译器指纹识别](http://hitcon.org/2016/CMT/slide/day1-r0-e-1.pdf)
- [使用 APKiD 检测盗版和恶意 Android 应用程序](http://rednaga.io/2016/07/31/detecting_pirated_and_malicious_android_apps_with_apkid/)
- [APKiD：适用于 Android 应用程序的 PEiD](https://github.com/enovella/cve-bio-enovella/blob/master/slides/bheu18-enovella-APKID.pdf)
- [APKiD：快速识别AppShielding产品](https://github.com/enovella/cve-bio-enovella/blob/master/slides/APKiD-NowSecure-Connect19-enovella.pdf)

### APKLab[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#apklab)

[APKLab](https://github.com/APKLab/APKLab)是一个方便的 Visual Studio Code 扩展，利用[apktool](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#apktool)和[jadx](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#jadx)等工具来启用应用程序解包、反编译、代码修补（例如针对 MITM）和直接从 IDE 重新打包等功能。

更多信息可以参考[APKLab的官方文档](https://apklab.surendrajat.xyz/)。

### 应用工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#apktool)

[Apktool](https://github.com/iBotPeaches/Apktool)用于解压 Android 应用程序包 (APK)。使用标准实用程序简单地解压缩 APK`unzip`会使一些文件无法读取。`AndroidManifest.xml`被编码为二进制 XML 格式，文本编辑器无法读取该格式。此外，应用程序资源仍打包到单个存档文件中。

当使用默认命令行标志Runtime(运行时)，apktool 会自动将 Android Manifest 文件解码为基于文本的 XML 格式并提取文件资源（它还会将 .DEX 文件反汇编为 smali 代码——我们将在本书后面重新讨论的功能） .

在解压缩的文件中，您通常可以找到（运行后`apktool d base.apk`）：

- AndroidManifest.xml：解码后的Android Manifest文件，可以在文本编辑器中打开和编辑。
- apktool.yml：包含有关 apktool 输出信息的文件
- original：包含 MANIFEST.MF 文件的文件夹，其中包含有关 JAR 文件中包含的文件的信息
- res：包含应用程序资源的目录
- smali：包含反汇编的 Dalvik 字节码的目录。

您还可以使用 apktool 将解码后的资源重新打包回二进制 APK/JAR。有关更多信息和实际示例，请参阅本章后面的“[探索应用程序包”部分和“ ](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#exploring-the-app-package)[Android 上的篡改和逆向工程](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/)”一章中的“[重新打包”部分。](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/#repackaging)

### apkx[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#apkx)

apkx 是流行的免费 DEX 转换器和 Java 反编译器的 Python 包装器。它自动执行 APK 的提取、转换和反编译。安装如下：

```
git clone https://github.com/muellerberndt/apkx
cd apkx
sudo ./install.sh
```

这应该将 apkx 复制到`/usr/local/bin`. 有关使用的更多信息，请参阅“逆向工程和篡改”一章的“[反编译 Java 代码”部分。](https://mas.owasp.org/MASTG/Android/0x05c-Reverse-Engineering-and-Tampering/#decompiling-java-code)

### busybox[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#busybox)

Busybox 将多个常见的 Unix 实用程序组合到一个小的单个可执行文件中。包含的实用程序通常比功能齐全的 GNU 对应程序具有更少的选项，但足以在小型或嵌入式系统上提供完整的环境。Busybox 可以通过从 Google Play 商店下载 Busybox 应用程序安装在有Root设备上。您也可以直接从[Busybox 网站](https://busybox.net/)下载二进制文件。下载后，制作一个`adb push busybox /data/local/tmp`可在手机上使用的可执行文件。[在Busybox FAQ](https://busybox.net/FAQ.html#getting_started)中可以找到关于如何安装和使用 Busybox 的快速概述。

### bytecode-viewer[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#bytecode-viewer)

[字节码查看器](https://bytecodeviewer.com/)(BCV) 是一个免费的开源 Java 反编译器框架，可在所有操作系统上运行。它是一种多功能工具，可用于反编译 Android 应用程序、查看 APK 资源（通过 apktool）并轻松编辑 APK（通过 Smali/Baksmali）。除了 APK，还可以查看 DEX、Java 类文件和 Java Jars。它的主要特性之一是在一个 GUI 下支持多个 Java 字节码反编译器。BCV 目前包括 Procyon、CFR、Fernflower、Krakatau 和 JADX-Core 反编译器。这些反编译器具有不同的优势，可以在使用 BCV 时轻松利用，尤其是在处理混淆程序时。

### Drozer[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#drozer)

[Drozer](https://github.com/FSecureLABS/drozer)是一个 Android 安全评估框架，允许您通过承担第三方应用程序与其他应用程序的 IPC 端点和底层操作系统交互的角色来搜索应用程序和设备中的安全漏洞。

使用 drozer 的优势在于它能够自动执行多项任务，并且可以通过模块进行扩展。这些模块非常有用，它们涵盖不同的类别，包括允许您使用简单命令扫描已知缺陷的扫描器类别，例如`scanner.provider.injection`检测系统中安装的所有应用程序的内容提供程序中的 SQL 注入的模块。如果没有 drozer，列出应用程序权限等简单任务需要几个步骤，包括反编译 APK 和手动分析结果。

#### 安装 Drozer[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#installing-drozer)

您可以参考[drozer GitHub 页面](https://github.com/FSecureLABS/drozer)（对于 Linux 和 Windows，对于 macOS 请参考这篇[博](https://fi5t.xyz/en/posts/drozer-on-mac/)文）和[drozer 网站](https://labs.withsecure.com/tools/drozer/)了解先决条件和安装说明。

#### 使用 Drozer[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-drozer)

在开始使用 drozer 之前，您还需要在 Android 设备本身上运行的 drozer 代理。[从 GitHub 发布页面](https://github.com/FSecureLABS/drozer/releases/)下载最新的 drozer 代理并使用`adb install drozer.apk`.

`adb forward tcp:31415 tcp:31415`设置完成后，您可以通过运行和启动与模拟器或通过 USB 连接的设备的会话`drozer console connect`。这称为直接模式，您可以[在“开始会话”部分的用户指南中](https://labs.withsecure.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)查看完整说明。另一种方法是在基础架构模式下运行 Drozer，在这种模式下，您运行的 drozer 服务器可以处理多个控制台和代理，并在它们之间路由会话。[您可以在用户指南的“基础架构模式”](https://labs.withsecure.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)部分找到有关如何在此模式下设置 drozer 的详细信息。

现在您已准备好开始分析应用程序。一个好的第一步是枚举应用程序的攻击面，这可以使用以下命令轻松完成：

```
dz> run app.package.attacksurface <package>
```

同样，如果没有 drozer，这将需要几个步骤。该模块`app.package.attacksurface`列出了导出的活动、广播接收器、Content Provider(内容提供者)和服务，因此它们是公开的，可以通过其他应用程序访问。一旦我们确定了我们的攻击面，我们就可以通过 drozer 与 IPC 端点交互，而无需编写单独的独立应用程序，因为某些任务需要它，例如与Content Provider(内容提供者)通信。

例如，如果应用程序有一个泄露敏感信息的导出活动，我们可以使用 Drozer 模块调用它`app.activity.start`：

```
dz> run app.activity.start --component <package> <component name>
```

之前的命令将启动活动，希望能泄露一些敏感信息。Drozer 具有适用于每种类型的 IPC 机制的模块。如果您想使用故意易受攻击的应用程序来试用模块，说明与 IPC 端点相关的常见问题，请下载[InsecureBankv2 。](https://mas.owasp.org/MASTG/Tools/0x08b-Reference-Apps/#insecurebankv2)密切关注扫描器类别中的模块，因为它们非常有助于自动检测系统包中的漏洞，特别是如果您使用的是手机公司提供的 ROM。甚至[谷歌系统包中的 SQL 注入漏洞在](https://issuetracker.google.com/u/0/issues/36965126)过去也被 drozer 识别出来。

#### 其他 Drozer 命令[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#other-drozer-commands)

以下是可用于开始探索 Android 的命令的非详尽列表：

```
# List all the installed packages
$ dz> run app.package.list

# Find the package name of a specific app
$ dz> run app.package.list -f (string to be searched)

# See basic information
$ dz> run app.package.info -a (package name)

# Identify the exported application components
$ dz> run app.package.attacksurface (package name)

# Identify the list of exported Activities
$ dz> run app.activity.info -a (package name)

# Launch the exported Activities
$ dz> run app.activity.start --component (package name) (component name)

# Identify the list of exported Broadcast receivers
$ dz> run app.broadcast.info -a (package name)

# Send a message to a Broadcast receiver
$ dz> run app.broadcast.send --action (broadcast receiver name) -- extra (number of arguments)

# Detect SQL injections in content providers
$ dz> run scanner.provider.injection -a (package name)
```

#### 其他 Drozer 资源[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#other-drozer-resources)

您可能会找到有用信息的其他资源包括：

- [官方 drozer 用户指南](https://labs.withsecure.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf)。
- [drozer GitHub 页面](https://github.com/FSecureLABS/drozer)
- [维基百科](https://github.com/FSecureLABS/drozer/wiki)

### gplaycli[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#gplaycli)

[gplaycli](https://github.com/matlink/gplaycli)是一个基于 Python 的 CLI 工具，用于从 Google Play 商店搜索、安装和更新 Android 应用程序。按照[安装步骤](https://github.com/matlink/gplaycli#installation)进行操作，您就可以运行它了。gplaycli 提供了几个选项，请参阅其帮助 ( `-h`) 以获取更多信息。

如果您不确定某个应用程序的包名称（或 AppID），您可以执行基于关键字的 APK 搜索 ( `-s`)：

```
$ gplaycli -s "google keep"

Title                          Creator     Size      Last Update  AppID                                    Version

Google Keep - notes and lists  Google LLC  15.78MB   4 Sep 2019   com.google.android.keep                  193510330
Maps - Navigate & Explore      Google LLC  35.25MB   16 May 2019  com.google.android.apps.maps             1016200134
Google                         Google LLC  82.57MB   30 Aug 2019  com.google.android.googlequicksearchbox  301008048
```

> 请注意，区域 (Google Play) 限制在使用 gplaycli 时适用。为了访问在您所在国家/地区受限制的应用程序，您可以使用替代应用程序商店，例如“[替代应用程序商店](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#alternative-app-stores)”中描述的那些。

### house[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#house)

[House](https://github.com/nccgroup/house)是一个用于 Android 应用程序的Runtime(运行时)移动应用程序分析工具包，由 NCC Group 开发和维护，用 Python 编写。

它利用在 root 设备上运行的 Frida 服务器或重新打包的 Android 应用程序中的 Frida 小工具。House 的目的是通过其方便的 Web GUI 提供一种简单的方法来制作 Frida 脚本的原型。

House 的安装说明和“操作指南”可以在[Github 存储库的自述文件中](https://github.com/nccgroup/house)找到。

### inspeckage[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#inspeckage)

开发用于提供 Android 应用程序动态分析的工具。通过将Hook应用到 Android API 的函数，Inspeckage 有助于了解 Android 应用程序在Runtime(运行时)正在做什么 - https://github.com/ac-pm/Inspeckage

### jadx[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#jadx)

jadx（Dex 到 Java 反编译器）是一个命令行和[GUI 工具](https://github.com/skylot/jadx/wiki/jadx-gui-features-overview)，用于从 Android DEX 和 APK 文件生成 Java 源代码 - https://github.com/skylot/jadx

### jdb[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#jdb)

允许设置断点和打印应用程序变量的 Java 调试器。jdb 使用 JDWP 协议 - https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html

### justtrustme[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#justtrustme)

绕过 SSL 证书固定的 Xposed 模块 - https://github.com/Fuzion24/JustTrustMe

### magisk[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#magisk)

`Magisk`（“魔术面具”）是一种根植您的 Android 设备的方法。它的特点在于对系统进行修改的方式。虽然其他Root工具会更改系统分区上的实际数据，但 Magisk 不会（称为“无系统”）。这提供了一种方法来隐藏对 root 敏感的应用程序（例如银行或游戏）的修改，并允许使用官方 Android OTA 升级，而无需事先取消对设备的 root 权限。

[您可以阅读GitHub 上的官方文档](https://topjohnwu.github.io/Magisk/)来熟悉 Magisk 。如果您没有安装 Magisk，您可以在[文档](https://topjohnwu.github.io/Magisk/install.html)中找到安装说明。如果你使用的是Android官方版本并打算升级，Magisk[在 GitHub 上提供了教程](https://topjohnwu.github.io/Magisk/ota.html)。

详细了解如何[使用 Magisk 对您的设备进行 root 操作](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#rooting-with-magisk)。

### proguard[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#proguard)

[ProGuard](https://www.guardsquare.com/en/products/proguard)是一个免费的 Java 类文件收缩器、优化器、混淆器和预验证器。它检测并删除未使用的类、字段、方法和属性，也可用于删除与日志记录相关的代码。

### RootCloak Plus[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#rootcloak-plus)

一个 Cydia Substrate 模块，用于检查常见的根指示 - https://github.com/devadvance/rootcloakplus

### scrcpy[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#scrcpy)

[Scrcpy](https://github.com/Genymobile/scrcpy)提供对通过 USB（或[TCP/IP](https://www.genymotion.com/blog/open-source-project-scrcpy-now-works-wirelessly/)）连接的 Android 设备的显示和控制。它不需要任何根访问权限，并且可以在 GNU/Linux、Windows 和 macOS 上运行。

### sslunpinning[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#sslunpinning)

绕过 SSL 证书固定的 Xposed 模块 - https://github.com/ac-pm/SSLUnpinning_Xposed

### termux[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#termux)

Termux 是一款适用于 Android 的终端仿真器，它提供了一个 Linux 环境，可以直接使用或不使用 root 并且无需设置。由于它有自己的 APT 包管理器（与其他终端仿真器应用程序相比，它有所不同），因此安装其他包是一项微不足道的任务。您可以使用命令搜索特定包并`pkg search <pkg_name>`使用`pkg install <pkg_name>`. [您可以直接从Google Play](https://play.google.com/store/apps/details?id=com.termux)安装 Termux 。

### Xposed[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#xposed)

[Xposed](http://repo.xposed.info/module/de.robv.android.xposed.installer)是一个框架，允许在Runtime(运行时)修改系统或应用程序方面和行为，而无需修改任何 Android 应用程序包 (APK) 或重新刷新。从技术上讲，它是 Zygote 的扩展版本，可以在启动新进程时导出用于运行 Java 代码的 API。在新实例化的应用程序的上下文中运行 Java 代码可以解析、Hook和覆盖属于该应用程序的 Java 方法。Xposed 使用[反射](https://docs.oracle.com/javase/tutorial/reflect/)来检查和修改正在运行的应用程序。由于应用程序二进制文件未被修改，因此更改会应用到内存中并仅在进程Runtime(运行时)持续存在。

要使用 Xposed，您需要首先按照[XDA-Developers Xposed framework hub](https://www.xda-developers.com/xposed-framework-hub/)上的说明在已获得 root 权限的设备上安装 Xposed 框架。模块可以通过 Xposed Installer 应用程序安装，并且可以通过 GUI 打开和关闭它们。

注意：鉴于 SafetyNet 很容易检测到 Xposed 框架的普通安装，我们建议使用 Magisk 安装 Xposed。这样，具有 SafetyNet 认证的应用程序应该有更高的机会使用 Xposed 模块进行测试。

Xposed 被比作 Frida。当你在有Root设备上运行 Frida 服务器时，你最终会得到一个类似有效的设置。当您想要进行动态检测时，这两个框架都可以提供很多价值。当 Frida 使应用程序崩溃时，您可以尝试使用 Xposed 进行类似操作。接下来，类似于大量的 Frida 脚本，您可以轻松地使用 Xposed 附带的众多模块之一，例如前面讨论的绕过 SSL 固定的模块（[JustTrustMe](https://github.com/Fuzion24/JustTrustMe)和[SSLUnpinning](https://github.com/ac-pm/SSLUnpinning_Xposed)）。Xposed 包括其他模块，例如[Inspeckage](https://github.com/ac-pm/Inspeckage)，它还允许您进行更深入的应用程序测试。最重要的是，您还可以创建自己的模块来为 Android 应用程序的常用安全机制打补丁。

Xposed也可以通过以下脚本安装在模拟器上：

```
#!/bin/sh
echo "Start your emulator with 'emulator -avd NAMEOFX86A8.0 -writable-system -selinux permissive -wipe-data'"
adb root && adb remount
adb install SuperSU\ v2.79.apk #binary can be downloaded from http://www.supersu.com/download
adb push root_avd-master/SuperSU/x86/su /system/xbin/su
adb shell chmod 0755 /system/xbin/su
adb shell setenforce 0
adb shell su --install
adb shell su --daemon&
adb push busybox /data/busybox #binary can be downloaded from https://busybox.net/
# adb shell "mount -o remount,rw /system && mv /data/busybox /system/bin/busybox && chmod 755 /system/bin/busybox && /system/bin/busybox --install /system/bin"
adb shell chmod 755 /data/busybox
adb shell 'sh -c "./data/busybox --install /data"'
adb shell 'sh -c "mkdir /data/xposed"'
adb push xposed8.zip /data/xposed/xposed.zip #can be downloaded from https://dl-xda.xposed.info/framework/
adb shell chmod 0755 /data/xposed
adb shell 'sh -c "./data/unzip /data/xposed/xposed.zip -d /data/xposed/"'
adb shell 'sh -c "cp /data/xposed/xposed/META-INF/com/google/android/*.* /data/xposed/xposed/"'
echo "Now adb shell and do 'su', next: go to ./data/xposed/xposed, make flash-script.sh executable and run it in that directory after running SUperSU"
echo "Next, restart emulator"
echo "Next, adb install XposedInstaller_3.1.5.apk"
echo "Next, run installer and then adb reboot"
echo "Want to use it again? Start your emulator with 'emulator -avd NAMEOFX86A8.0 -writable-system -selinux permissive'"
```

请注意，在撰写本文时，Xposed 无法在 Android 9（API 级别 28）上运行。然而，它于 2019 年以 EdXposed 的名义被非正式移植，支持 Android 8-10（API 级别 26 至 29）。[您可以在EdXposed](https://github.com/ElderDrivers/EdXposed) Github存储库中找到代码和使用示例。

## 适用于 iOS 的工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tools-for-ios)

### 注入[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#bfinject)

一种将任意 dylib 加载到正在运行的 App Store 应用程序中的工具。它内置支持解密 App Store 应用程序，并与 iSpy 和 Cycript 捆绑在一起 - https://github.com/BishopFox/bfinject

### BinaryCookieReader[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#binarycookiereader)

从二进制 Cookies.binarycookies 文件中转储所有 cookie 的工具 - https://github.com/as0ler/BinaryCookieReader/blob/master/BinaryCookieReader.py

### Burp Suite 手机助手[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#burp-suite-mobile-assistant)

绕过证书固定并能够注入应用程序的工具 - https://portswigger.net/burp/documentation/desktop/tools/mobile-assistant

### class-dump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#class-dump)

[Steve Nygard 的类转储](http://stevenygard.com/projects/class-dump/)是一个命令行实用程序，用于检查存储在 Mach-O（Mach 对象）文件中的 Objective-C Runtime(运行时)信息。它为类、类别和协议生成声明。

### class-dump-z[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#class-dump-z)

[class-dump-z](https://code.google.com/archive/p/networkpx/wikis/class_dump_z.wiki)是用 C++ 从头开始重写的 class-dump，避免使用动态调用。删除这些不必要的调用使 class-dump-z 比其前身快近 10 倍。

### class-dump-dyld[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#class-dump-dyld)

[Elias Limneos 的 class-dump-dyld](https://github.com/limneos/classdump-dyld/)允许直接从共享缓存中转储和检索符号，无需先提取文件。它可以从应用程序二进制文件、库、框架、捆绑包或整个 dyld_shared_cache 生成头文件。目录或整个 dyld_shared_cache 可以递归地大量转储。

### clutch[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#clutch)

Clutch 解密 iOS 应用程序并将指定的 bundleID 转储到二进制或 IPA 文件中 - https://github.com/KJCracks/Clutch

### cyberduck[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#cyberduck)

适用于 Mac 和 Windows 的 Libre FTP、SFTP、WebDAV、S3、Azure 和 OpenStack Swift 浏览器 - [https://cyberduck.io](https://cyberduck.io/)

### cycript[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#cycript)

Cydia Substrate（以前称为 MobileSubstrate）是用于在 iOS 上开发 Cydia Runtime(运行时)补丁（即所谓的“Cydia Substrate Extensions”）的标准框架。它带有 Cynject，这是一种为 C 语言提供代码注入支持的工具。

Cycript 是由 Jay Freeman（又名 Saurik）开发的一种脚本语言。它将 JavaScriptCore VM 注入到正在运行的进程中。通过 Cycript 交互式控制台，用户可以使用混合的 Objective-C++ 和 JavaScript 语法来操纵该过程。在正在运行的进程中访问和实例化 Objective-C 类也是可能的。

为了安装 Cycript，首先下载、解压并安装 SDK。

```
#on iphone
$ wget https://cydia.saurik.com/api/latest/3 -O cycript.zip && unzip cycript.zip
$ sudo cp -a Cycript.lib/*.dylib /usr/lib
$ sudo cp -a Cycript.lib/cycript-apl /usr/bin/cycript
```

要生成交互式 Cycript shell，请运行“./cycript”或“cycript”（如果 Cycript 在您的路径上）。

```
$ cycript
cy#
```

要注入正在运行的进程，我们首先需要找到进程 ID (PID)。运行应用程序并确保应用程序在前台。运行`cycript -p <PID>`会将 Cycript 注入进程。为了说明，我们将注入 SpringBoard（始终运行）。

```
$ ps -ef | grep SpringBoard
501 78 1 0 0:00.00 ?? 0:10.57 /System/Library/CoreServices/SpringBoard.app/SpringBoard
$ ./cycript -p 78
cy#
```

您可以尝试的第一件事就是获取应用程序实例 ( `UIApplication`)，您可以使用 Objective-C 语法：

```
cy# [UIApplication sharedApplication]
cy# var a = [UIApplication sharedApplication]
```

现在使用该变量获取应用程序的委托类：

```
cy# a.delegate
```

让我们尝试使用 Cycript 在 SpringBoard 上触发警报消息。

```
cy# alertView = [[UIAlertView alloc] initWithTitle:@"OWASP MASTG" message:@"Mobile Application Security Testing Guide"  delegate:nil cancelButtonitle:@"OK" otherButtonTitles:nil]
#"<UIAlertView: 0x1645c550; frame = (0 0; 0 0); layer = <CALayer: 0x164df160>>"
cy# [alertView show]
cy# [alertView release]
```

![img](https://mas.owasp.org/assets/Images/Chapters/0x06c/cycript_sample.png)

使用 Cycript 查找应用程序的文档目录：

```
cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]
#"file:///var/mobile/Containers/Data/Application/A8AE15EE-DC8B-4F1C-91A5-1FED35212DF/Documents/"
```

该命令`[[UIApp keyWindow] recursiveDescription].toString()`返回 的视图层次结构`keyWindow`。显示了每个子视图和子子视图的描述`keyWindow`。缩进空间反映了视图之间的关系。例如，`UILabel`、`UITextField`和`UIButton`是 的子视图`UIView`。

```
cy# [[UIApp keyWindow] recursiveDescription].toString()
`<UIWindow: 0x16e82190; frame = (0 0; 320 568); gestureRecognizers = <NSArray: 0x16e80ac0>; layer = <UIWindowLayer: 0x16e63ce0>>
  | <UIView: 0x16e935f0; frame = (0 0; 320 568); autoresize = W+H; layer = <CALayer: 0x16e93680>>
  |    | <UILabel: 0x16e8f840; frame = (0 40; 82 20.5); text = 'i am groot!'; hidden = YES; opaque = NO; autoresize = RM+BM; userInteractionEnabled = NO; layer = <_UILabelLayer: 0x16e8f920>>
  |    | <UILabel: 0x16e8e030; frame = (0 110.5; 320 20.5); text = 'A Secret Is Found In The ...'; opaque = NO; autoresize = RM+BM; userInteractionEnabled = NO; layer = <_UILabelLayer: 0x16e8e290>>
  |    | <UITextField: 0x16e8fbd0; frame = (8 141; 304 30); text = ''; clipsToBounds = YES; opaque = NO; autoresize = RM+BM; gestureRecognizers = <NSArray: 0x16e94550>; layer = <CALayer: 0x16e8fea0>>
  |    |    | <_UITextFieldRoundedRectBackgroundViewNeue: 0x16e92770; frame = (0 0; 304 30); opaque = NO; autoresize = W+H; userInteractionEnabled = NO; layer = <CALayer: 0x16e92990>>
  |    | <UIButton: 0x16d901e0; frame = (8 191; 304 30); opaque = NO; autoresize = RM+BM; layer = <CALayer: 0x16d90490>>
  |    |    | <UIButtonLabel: 0x16e72b70; frame = (133 6; 38 18); text = 'Verify'; opaque = NO; userInteractionEnabled = NO; layer = <_UILabelLayer: 0x16e974b0>>
  |    | <_UILayoutGuide: 0x16d92a00; frame = (0 0; 0 20); hidden = YES; layer = <CALayer: 0x16e936b0>>
  |    | <_UILayoutGuide: 0x16d92c10; frame = (0 568; 0 0); hidden = YES; layer = <CALayer: 0x16d92cb0>>`
```

您还可以使用 Cycript 的内置函数，例如`choose`在堆中搜索给定 Objective-C 类的实例：

```
cy# choose(SBIconModel)
[#"<SBIconModel: 0x1590c8430>"]
```

在[Cycript 手册](http://www.cycript.org/manual/)中了解更多信息。

### Cydia[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#cydia)

Cydia 是 Jay Freeman（又名“saurik”）为越狱设备开发的替代应用程序商店。它提供图形用户界面和高级打包工具 (APT) 版本。您可以通过 Cydia 轻松访问许多“未经批准”的应用程序包。大多数越狱会自动安装 Cydia。

越狱设备上的许多工具都可以使用 Cydia 安装，Cydia 是适用于 iOS 设备的非官方 AppStore，可让您管理存储库。**在 Cydia 中，您应该通过导航到Sources** -> **Edit**添加（如果默认情况下尚未完成）以下存储库，然后单击左上角的**Add ：**

- http://apt.thebigboss.org/repofiles/cydia/：最受欢迎的存储库之一是 BigBoss，它包含各种包，例如 BigBoss Recommended Tools 包。
- https://cydia.akemi.ai/：添加“Karen's Repo”以获取 AppSync 包。
- [https://build.frida.re](https://build.frida.re/)：通过将存储库添加到 Cydia 来安装 Frida。
- [https://repo.chariz.io](https://repo.chariz.io/)：在 iOS 11 上管理越狱时很有用。
- https://apt.bingner.com/：另一个存储库是 Elucubratus，它有一些很好的工具，当你使用 Unc0ver 在 iOS 12 上安装 Cydia 时就会安装它。

> 如果您使用的是 Sileo App Store，请记住 Sileo 兼容层在 Cydia 和 Sileo 之间共享您的源，但是，Cydia 无法删除添加到 Sileo 中的源，而[Sileo 也无法删除添加到 Cydia 中的源](https://www.idownloadblog.com/2019/01/11/install-sileo-package-manager-on-unc0ver-jailbreak/)。当您尝试删除来源时，请记住这一点。

添加上面所有建议的存储库后，您可以从 Cydia 安装以下有用的软件包以开始使用：

- adv-cmds：高级命令行，包括finger、fingerd、last、lsvfs、md、ps等工具。
- AppList：允许开发者查询已安装的应用程序列表，并提供基于列表的首选项面板。
- Apt：Advanced Package Tool，您可以使用它来管理已安装的包，类似于 DPKG，但方式更友好。这允许您从 Cydia 存储库安装、卸载、升级和降级软件包。来自 Elucubratus。
- AppSync Unified：允许您同步和安装未签名的 iOS 应用程序。
- BigBoss 推荐工具：安装许多用于安全测试的有用命令行工具，包括 iOS 中缺少的标准 Unix 实用程序，包括 wget、unrar、less 和 sqlite3 客户端。
- class-dump：一个命令行工具，用于检查存储在 Mach-O 文件中的 Objective-C Runtime(运行时)信息并生成带有类接口的头文件。
- class-dump-z：一个命令行工具，用于检查存储在 Mach-O 文件中的 Swift Runtime(运行时)信息并生成带有类接口的头文件。这无法通过 Cydia 获得，因此请参阅[安装步骤](https://iosgods.com/topic/6706-how-to-install-class-dump-z-on-any-64bit-idevices-how-to-use-it/)，以便在您的 iOS 设备上运行 class-dump-z。请注意，class-dump-z 没有得到维护，并且不能很好地与 Swift 一起使用。建议改用[dsdump](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#dsdump)。
- Clutch：用于解密应用程序可执行文件。
- Cycript：是一个内联、优化、Cycript-to-JavaScript 编译器和即时模式控制台环境，可以注入正在运行的进程（与 Substrate 关联）。
- Cydia Substrate：一个平台，可以通过动态应用程序操作或内省更轻松地开发第三方 iOS 附加组件。
- cURL：是一个众所周知的 http 客户端，您可以使用它更快地将包下载到您的设备。例如，当您需要在您的设备上安装不同版本的 Frida-server 时，这会很有帮助。
- Darwin CC 工具：一组有用的工具，如 nm 和 strip，能够审计 mach-o 文件。
- IPA Installer Console：用于从命令行安装 IPA 应用程序包的工具。安装后，将有两个命令可用`installipa`并且`ipainstaller`它们都是相同的。
- Frida：一款可用于动态检测的应用程序。请注意，随着时间的推移，Frida 已更改其 API 的实现，这意味着某些脚本可能仅适用于特定版本的 Frida-server（这会迫使您也在 macOS 上更新/降级该版本）。建议运行通过 APT 或 Cydia 安装的 Frida Server。之后可以按照[此 Github 问题](https://github.com/AloneMonkey/frida-ios-dump/issues/65#issuecomment-490790602)的说明进行升级/降级。
- Grep：过滤行的便捷工具。
- Gzip：一个众所周知的 ZIP 实用程序。
- PreferenceLoader：一种基于 Substrate 的实用程序，允许开发人员向设置应用程序添加条目，类似于 App Store 应用程序使用的 SettingsBundles。
- Socket CAT：一个实用程序，您可以使用它连接到套接字以读取和写入消息。如果您想跟踪 iOS 12 设备上的系统日志，这会派上用场。

除了 Cydia 之外，还有其他几个开源工具可用并且应该安装，例如[Introspy](https://github.com/iSECPartners/Introspy-iOS)。

除了 Cydia，您还可以通过 ssh 连接到您的 iOS 设备，您可以直接通过 apt-get 安装软件包，例如 adv-cmds。

```
apt-get update
apt-get install adv-cmds
```

### dsdump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#dsdump)

[dsdump](https://github.com/DerekSelander/dsdump)是一个转储 Objective-C 类和 Swift 类型描述符（类、结构、枚举）的工具。它仅支持 Swift 版本 5 或更高版本，不支持 ARM 32 位二进制文件。

以下示例显示了如何转储 iOS 应用程序的 Objective-C 类和 Swift 类型描述符。

首先验证应用程序的主二进制文件是否为包含 ARM64 的 FAT 二进制文件：

```
$ otool -hv [APP_MAIN_BINARY_FILE]
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
   MH_MAGIC     ARM         V7  0x00     EXECUTE    39       5016   NOUNDEFS DYLDLINK TWOLEVEL PIE
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    38       5728   NOUNDEFS DYLDLINK TWOLEVEL PIE
```

如果是，那么我们将“--arch”参数指定为“arm64”，否则如果二进制文件仅包含 ARM64 二进制文件，则不需要。

```
# Dump the Objective-C classes to a temporary file
$ dsdump --objc --color --verbose=5 --arch arm64 --defined [APP_MAIN_BINARY_FILE] > /tmp/OBJC.txt

# Dump the Swift type descriptors to a temporary file if the app is implemented in Swift
$ dsdump --swift --color --verbose=5 --arch arm64 --defined [APP_MAIN_BINARY_FILE] > /tmp/SWIFT.txt
```

[您可以在本文](https://derekselander.github.io/dsdump/)中找到有关 dsdump 的内部工作原理以及如何以编程方式检查 Mach-O 二进制文件以显示已编译的 Swift 类型和 Objective-C 类的更多信息。

### dsdump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#dsdump)

Dumpdecrypted 将来自加密 iPhone 应用程序的解密 mach-o 文件从内存转储到磁盘 - https://github.com/stefanesser/dumpdecrypted

### filezilla[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#filezilla)

支持 FTP、SFTP 和 FTPS（FTP over SSL/TLS）的解决方案 - https://filezilla-project.org/download.php?show_all=1

确保您的系统上安装了以下内容：

### frida-cycript[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-cycript)

Cycript 的一个分支，包括一个名为 Mjølner 的全新Runtime(运行时)，由 Frida 提供支持。这使得 frida-cycript 可以在 frida-core 维护的所有平台和架构上运行 - https://github.com/nowsecure/frida-cycript

### frida-ios-dump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#frida-ios-dump)

[Frida-ios-dump](https://github.com/AloneMonkey/frida-ios-dump)是一个 Python 脚本，可帮助您从 iOS 设备检索 iOS 应用程序 (IPA) 的解密版本。它同时支持 Python 2 和 Python 3，并且需要在你的 iOS 设备上运行 Frida（越狱与否）。此工具使用 Frida 的[内存 API](https://www.frida.re/docs/javascript-api/#memory)转储正在运行的应用程序的内存并重新创建 IPA 文件。因为代码是从内存中提取出来的，所以会自动解密。有关如何使用它的详细说明，请参阅[“使用 Frida-ios-dump”部分。](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#using-frida-ios-dump)

### fridpa[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#fridpa)

用于修补 iOS 应用程序（IPA 文件）并在非越狱设备上工作的自动包装器脚本 - https://github.com/tanprathan/Fridpa

### gdb[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#gdb)

执行 iOS 应用程序Runtime(运行时)分析的工具 - https://cydia.radare.org/pool/main/g/gdb/

### ifunbox[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#ifunbox)

[iFunBox](http://www.i-funbox.com/)是一个支持 iOS 的文件和应用程序管理工具。您可以[为 Windows 和 macOS 下载它](http://www.i-funbox.com/en_download.html)。

它具有多种功能，例如应用程序安装、无需越狱即可访问应用程序沙箱等。

### Introspy-iOS[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#introspy-ios)

帮助了解 iOS 应用程序在Runtime(运行时)做什么并协助识别潜在安全问题的黑盒工具 - https://github.com/iSECPartners/Introspy-iOS

### iosbackup[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#iosbackup)

[`iOSbackup`](https://github.com/avibrazil/iOSbackup)是一个 Python 3 类，它从 iTunes 在 Mac 和 Windows 上创建的密码加密的 iOS 备份中读取和提取文件。

### ios-deploy[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#ios-deploy)

使用[ios-deploy](https://github.com/ios-control/ios-deploy)，您可以从命令行安装和调试 iOS 应用程序，而无需使用 Xcode。它可以通过 brew 在 macOS 上安装：

```
brew install ios-deploy
```

或者：

```
git clone https://github.com/ios-control/ios-deploy.git
cd ios-deploy/
xcodebuild
cd build/Release
./ios-deploy
ln -s <your-path-to-ios-deploy>/build/Release/ios-deploy /usr/local/bin/ios-deploy
```

最后一行创建一个符号链接并使可执行文件在系统范围内可用。重新加载您的 shell 以使新命令可用：

```
zsh: # . ~/.zshrc
bash: # . ~/.bashrc
```

### iproxy[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#iproxy)

用于通过 SSH 通过 USB 连接到越狱 iPhone 的工具 - https://github.com/tcurdt/iProxy

### itunnel[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#itunnel)

用于通过 USB 转发 SSH 的工具 - https://code.google.com/p/iphonetunnel-usbmuxconnectbyport/downloads/list

### keychain-dumper[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#keychain-dumper)

[Keychain-dumper](https://github.com/mechanico/Keychain-Dumper)是一种 iOS 工具，用于在 iOS 设备越狱后检查攻击者可以使用哪些钥匙串项目。获取该工具的最简单方法是从其 GitHub 存储库下载二进制文件并从您的设备运行它：

```
$ git clone https://github.com/ptoomey3/Keychain-Dumper
$ scp -P 2222 Keychain-Dumper/keychain_dumper root@localhost:/tmp/
$ ssh -p 2222 root@localhost
iPhone:~ root# chmod +x /tmp/keychain_dumper
iPhone:~ root# /tmp/keychain_dumper
```

有关使用说明，请参阅[Keychain-dumper](https://github.com/mechanico/Keychain-Dumper) GitHub 页面。

### lldb[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#lldb)

Apple Xcode 的调试器，用于调试 iOS 应用程序 - https://lldb.llvm.org/

### machooview[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#machooview)

[MachoOView](https://sourceforge.net/projects/machoview/)是一个有用的可视化 Mach-O 文件浏览器，它还允许对 ARM 二进制文件进行文件内编辑。

### optool[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#optool)

[optool](https://github.com/alexzielenski/optool)是一个与 MachO 二进制文件交互的工具，用于插入/删除加载命令、剥离代码签名、重新签名和删除 aslr。

安装它：

```
git clone https://github.com/alexzielenski/optool.git
cd optool/
git submodule update --init --recursive
xcodebuild
ln -s <your-path-to-optool>/build/Release/optool /usr/local/bin/optool
```

最后一行创建一个符号链接并使可执行文件在系统范围内可用。重新加载您的 shell 以使新命令可用：

```
zsh: # . ~/.zshrc
bash: # . ~/.bashrc
```

### otool[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#otool)

[otool](https://www.manpagez.com/man/1/otool/)是一个用于显示目标文件或库的特定部分的工具。它适用于 Mach-O 文件和通用文件格式。

### passionfruit[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#passionfruit)

[Passionfruit](https://github.com/chaitin/passionfruit/)是一个 iOS 应用程序黑盒评估工具，它在 iOS 设备上使用 Frida 服务器，并通过基于 Vue.js 的 GUI 可视化许多标准应用程序数据。它可以用 npm 安装。

```
$ npm install -g passionfruit
$ passionfruit
listening on http://localhost:31337
```

当您执行该命令时`passionfruit`，本地服务器将在端口 31337 上启动。将您的越狱设备连接到正在运行的 Frida 服务器，或者将带有重新打包的应用程序（包括 Frida）的非越狱设备通过 USB 连接到您的 macOS 设备。单击“iPhone”图标后，您将获得所有已安装应用程序的概览：

![img](https://mas.owasp.org/assets/Images/Chapters/0x06b/Passionfruit.png)

使用 Passionfruit 可以探索有关 iOS 应用程序的各种信息。选择 iOS 应用程序后，您可以执行许多任务，例如：

- 获取有关二进制文件的信息
- 查看应用程序使用的文件夹和文件并下载它们
- 检查 Info.plist
- 获取 iOS 设备上显示的应用程序屏幕的 UI 转储
- 列出应用加载的模块
- 转储类名
- 转储钥匙串项目
- 访问 NSLog 跟踪

### plutil[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#plutil)

可以在二进制版本和 XML 版本之间转换 .plist 文件的程序 - https://www.theiphonewiki.com/wiki/Plutil

### security[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#security)

[`security`](https://ss64.com/osx/security.html)是管理钥匙链、密钥、证书和安全框架的 macOS 命令。

### sileo[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#sileo)

由于 iOS 11 越狱引入了[Sileo](https://cydia-app.com/sileo/)，这是一个新的 iOS 设备越狱应用程序商店。iOS 12的越狱[Chimera](https://chimera.sh/)也依赖 Sileo 作为包管理器。

### simctl[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#simctl)

simctl 是一个 Xcode 工具，它允许您通过命令行与 iOS 模拟器交互，例如管理模拟器、启动应用程序、截屏或收集它们的日志。

### ssl-kill-switch-2[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#ssl-kill-switch-2)

用于在 iOS 和 macOS 应用程序中禁用 SSL 证书验证的黑盒工具 - 包括证书固定 - https://github.com/nabla-c0d3/ssl-kill-switch2

### swift-demangle[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#swift-demangle)

swift-demangle 是一个 Xcode 工具，可以对 Swift 符号进行 demangles。有关详细信息，请在`xcrun swift-demangle -help`安装后运行。

### TablePlus[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tableplus)

[TablePlus](https://tableplus.io/)是一款适用于 Windows 和 macOS 的工具，用于检查数据库文件，如 Sqlite 等。当从 iOS 设备转储数据库文件并使用 GUI 工具分析它们的内容时，这在 iOS 交互过程中非常有用。

### usbmuxd[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#usbmuxd)

[usbmuxd](https://github.com/libimobiledevice/usbmuxd)是一个监控 USB iPhone 连接的套接字守护进程。您可以使用它将移动设备的本地主机侦听套接字映射到主机上的 TCP 端口。这使您可以方便地通过 SSH 连接到您的 iOS 设备，而无需设置实际的网络连接。当 usbmuxd 检测到 iPhone 在正常模式下Runtime(运行时)，它会连接到手机并开始中继它通过`/var/run/usbmuxd`.

### weak-classdump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#weak-classdump)

为传递给函数的类生成头文件的 Cycript 脚本。当无法使用 classdump 或 dumpdecrypted、二进制文件被加密等时最有用 - https://github.com/limneos/weak_classdump

### Xcode[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#xcode)

Xcode 是一个适用于 macOS 的集成开发环境 (IDE)，其中包含一套用于为 macOS、iOS、watchOS 和 tvOS 开发软件的工具。您可以[从 Apple 官方网站免费下载 Xcode](https://developer.apple.com/xcode/ide/)。Xcode 将为您提供不同的工具和功能来与 iOS 设备交互，这在渗透测试期间很有帮助，例如分析日志或应用程序的侧载。

### xcode-command-line-tools[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#xcode-command-line-tools)

安装[Xcode](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#xcode)后，为了让所有开发工具在系统范围内可用，建议安装 Xcode Command Line Tools 包。这在测试 iOS 应用程序期间会很方便，因为一些工具（例如反对）也依赖于此包的可用性。您可以[从 Apple 官方网站下载它，](https://developer.apple.com/download/more/)也可以直接从您的终端安装它：

```
xcode-select --install
```

### xcrun[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#xcrun)

[`xcrun`](https://www.manpagez.com/man/1/xcrun/)可以用于从命令行调用 Xcode 开发人员工具，而无需将它们放在路径中。例如，您可能想用它来定位和运行 swift-demangle 或 simctl。

## 网络拦截和监控工具[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tools-for-network-interception-and-monitoring)

### Androidtcpdump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#android-tcpdump)

适用于 Android 的命令行数据包捕获实用程序 - [https://www.androidtcpdump.com](https://www.androidtcpdump.com/)

### bettercap[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#bettercap)

一个强大的框架，旨在为安全研究人员和逆向工程师提供一种易于使用的一体化解决方案，适用于 Wi-Fi、低功耗蓝牙、无线 HID 劫持和以太网网络侦察。它可以在网络渗透测试期间使用，以模拟中间人 (MITM) 攻击。这是通过对目标计算机执行[ARP 中毒或欺骗来实现的。](https://en.wikipedia.org/wiki/ARP_spoofing)当此类攻击成功时，两台计算机之间的所有数据包都将重定向到第三台计算机，该计算机充当中间人并能够拦截流量进行分析。

> bettercap 是执行 MITM 攻击的强大工具，现在应该是首选，而不是 ettercap。另请参阅[为什么使用另一个 MITM 工具？](https://www.bettercap.org/legacy/#why-another-mitm-tool)在 bettercap 网站上。

bettercap 适用于所有主要的 Linux 和 Unix 操作系统，并且应该是它们各自的软件包安装机制的一部分。您需要将其安装在充当 MITM 的主机上。在 macOS 上，可以使用 brew 安装它。

```
brew install bettercap
```

对于 Kali Linux，您可以使用以下命令安装 bettercap `apt-get`：

```
apt-get update
apt-get install bettercap
```

[LinuxHint](https://linuxhint.com/install-bettercap-on-ubuntu-18-04-and-use-the-events-stream/)上也有 Ubuntu Linux 18.04 的安装说明。

### burp-suite[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#burp-suite)

Burp Suite 是一个用于执行安全测试移动和 Web 应用程序的集成平台 - https://portswigger.net/burp/releases

它的工具无缝协作以支持整个测试过程，从攻击面的初始映射和分析到查找和利用安全漏洞。Burp Proxy 作为 Burp Suite 的 Web 代理服务器运行，Burp Suite 定位为浏览器和 Web 服务器之间的中间人。Burp Suite 允许您拦截、检查和修改传入和传出的原始 HTTP 流量。

设置 Burp 来代理您的流量非常简单。我们假设您的设备和主机都连接到允许客户端到客户端流量的 Wi-Fi 网络。

PortSwigger 提供了关于设置 Android 和 iOS 设备以使用 Burp 的很好的教程：

- [配置 Android 设备以使用 Burp](https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp)。
- [将 Burp 的 CA 证书安装到 Android 设备](https://support.portswigger.net/customer/portal/articles/1841102-installing-burp-s-ca-certificate-in-an-android-device)。
- [配置 iOS 设备以使用 Burp](https://support.portswigger.net/customer/portal/articles/1841108-configuring-an-ios-device-to-work-with-burp)。
- [将 Burp 的 CA 证书安装到 iOS 设备](https://support.portswigger.net/customer/portal/articles/1841109-installing-burp-s-ca-certificate-in-an-ios-device)。

[更多信息请参考Android](https://mas.owasp.org/MASTG/Android/0x05b-Basic-Security_Testing/#setting-up-an-interception-proxy)和[iOS](https://mas.owasp.org/MASTG/iOS/0x06b-Basic-Security-Testing/#setting-up-an-interception-proxy) “基本安全测试”章节中的“设置拦截代理”部分。

### mitm-relay[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#mitm-relay)

通过 Burp 和其他支持 SSL 和 STARTTLS 拦截的脚本拦截和修改非 HTTP 协议 - https://github.com/jrmdev/mitm_relay

### OWASP ZAP[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#owasp-zap)

[OWASP ZAP](https://owasp.org/www-project-zap/)（Zed Attack Proxy）是一款免费的安全工具，可帮助自动查找 Web 应用程序和 Web 服务中的安全漏洞 - https://github.com/zaproxy/zaproxy

### tcpdump[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#tcpdump)

命令行数据包捕获实用程序 - https://www.tcpdump.org/

### wireshark[¶](https://mas.owasp.org/MASTG/Tools/0x08a-Testing-Tools/#wireshark)

开源数据包分析器 - https://www.wireshark.org/download.html
